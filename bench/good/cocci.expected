Warning: you are using the standard library and/or the %inline keyword. We
recommend switching on --infer in order to avoid obscure type error messages.
%{

(* Not clear how to allow function declarations to specify a return type
and how to allow both to be specified as static, because they are in
different rules.  The rules seem to have to be combined, which would allow
functions to be declared as local variables *)

(* Not clear how to let a function have a parameter of type void.  At the
moment, void is allowed to be the type of a variable, which is wrong, and a
parameter needs both a type and an identifier *)
module Ast0 = Ast0_cocci
module Ast = Ast_cocci
module P = Parse_aux

%}
%start iso_main
%start iso_meta_main
%start meta_main
%start minus_main
%start never_used
%start plus_main
%start reinit
%start rule_name
%token <Data.clt> Tvolatile
%token <Data.clt> Tvoid
%token <Data.clt> Tunsigned
%token <Data.clt> Tunion
%token <Data.clt> Tstruct
%token <Data.clt> Tstatic
%token <Data.clt> Tsigned
%token <Data.clt> Tshort
%token <Data.clt> Tregister
%token <Data.clt> Tlong
%token Tlist
%token <Data.clt> Tint
%token <Data.clt> Tinline
%token <Data.clt> Tfloat
%token <Data.clt> Textern
%token <Data.clt> Tdouble
%token <Data.clt> Tconst
%token <Data.clt> Tchar
%token <Data.clt> Tauto
%token <string * Data.clt> Tattr
%token TWords
%token TWhy0
%token <Data.clt> TWhy
%token <Data.clt> TWhile
%token <Data.clt> TWhen
%token TUsing
%token TTypedef
%token <string * Data.clt> TTypeId
%token TType
%token <Data.clt> TTilde
%token <Data.clt> TSwitch
%token <string * Data.clt> TString
%token TStatement
%token <Data.clt> TSizeof
%token <string> TRuleName
%token TRightIso
%token <Data.clt> TReturn
%token TPure
%token <Data.clt> TPtrOp
%token <Data.clt> TPtVirg
%token <string> TPragma
%token <string * Data.clt> TPlusFile
%token TPlus0
%token TParameter
%token TOn
%token <Data.clt> TOPar0
%token <Data.clt> TOPar
%token <Data.clt> TOEllipsis
%token <Data.clt> TOCro
%token <Data.clt> TOBrace
%token TNothing
%token <string * Data.clt> TMinusFile
%token <Data.clt> TMid0
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaType
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaStmList
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaStm
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaParamList
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaParam
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaLocalFunc
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaId
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaFunc
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaExpList
%token <(string * string) * Ast0_cocci.pure * Type_cocci.typeC list option *
          Data.clt> TMetaExp
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaErr
%token <(string * string) * Ast0_cocci.pure * Type_cocci.typeC list option *
          Data.clt> TMetaConst
%token TMPtVirg
%token TLocal
%token <Data.clt> TLineEnd
%token TIsoType
%token TIsoTopLevel
%token TIsoStatement
%token TIsoExpression
%token TIsoDeclaration
%token TIso
%token TInvalid
%token <string * Data.clt> TInt
%token <string * Data.clt> TIncludeNL
%token <string * Data.clt> TIncludeL
%token <Data.clt> TInc
%token TIdentifier
%token <string * Data.clt> TIdent
%token TFunction
%token <Data.clt> TFunDecl
%token TFresh
%token <Data.clt> TFor
%token <string * Data.clt> TFloat
%token TExtends
%token TExpression
%token TError
%token <Data.clt> TEq
%token <Data.clt> TEllipsis
%token <Data.clt> TDotDot
%token <Data.clt> TDot
%token <Data.clt> TDo
%token TDepends
%token <Data.clt * token * int> TDefineParam
%token <Data.clt * token> TDefine
%token <Data.clt> TDefault
%token <string * Data.clt> TDeclarerId
%token TDeclarer
%token <Data.clt> TDec
%token <Data.clt> TContinue
%token TContext
%token TConstant
%token <Data.clt> TComma
%token <string * Data.clt> TChar
%token <Data.clt> TCase
%token <Data.clt> TCPar0
%token <Data.clt> TCPar
%token <Data.clt> TCEllipsis
%token <Data.clt> TCCro
%token <Data.clt> TCBrace
%token <Data.clt> TBreak
%token TBang0
%token <Data.clt> TBang
%token <Ast_cocci.assignOp * Data.clt> TAssign
%token TArobArob
%token TArob
%token EOF
%token <Data.clt> TIf
%token <Data.clt> TElse
%token <Data.clt> TOrLog
%token <Data.clt> TAndLog
%token <Data.clt> TOr
%token <Data.clt> TXor
%token <Data.clt> TAnd
%token <Data.clt> TNotEq
%token <Data.clt> TEqEq
%token <Data.clt> TSupEq
%token <Data.clt> TSup
%token <Data.clt> TInfEq
%token <Data.clt> TInf
%token <Data.clt> TShr
%token <Data.clt> TShl
%token <Data.clt> TPlus
%token <Data.clt> TMinus
%token <Data.clt> TMul
%token <Data.clt> TMod
%token <Data.clt> TDiv
%nonassoc TIf 
%nonassoc TElse 
%left TOrLog 
%left TAndLog 
%left TOr 
%left TXor 
%left TAnd 
%left TNotEq TEqEq 
%left TSupEq TSup TInfEq TInf 
%left TShr TShl 
%left TPlus TMinus 
%left TMul TMod TDiv 
%type <Ast0_cocci.anything list list> iso_main
%type <(Ast_cocci.metavar,Ast_cocci.metavar) Common.either list> iso_meta_main
%type <(Ast_cocci.metavar,Ast_cocci.metavar) Common.either list> meta_main
%type <Ast0_cocci.rule> minus_main
%type <unit> never_used
%type <Ast0_cocci.rule> plus_main
%type <unit> reinit
%type <string * Ast_cocci.dependency list * string option> rule_name
%%

reinit:
| 
    { }

meta_main:
| m = metadec
    { m (!Ast0.rule_name) }

struct_or_union:
| s = Tstruct
    { P.clt2mcode Ast.Struct s }
| u = Tunion
    { P.clt2mcode Ast.Union u }

option_eexpr_:
| 
    { None }
| x = eexpr
    { Some x }

loption_minus_function_decl_statement_or_expression_:
| 
    { [] }
| x = minus_function_decl_statement_or_expression
    { x }

loption_fun_exp_decl_statement_list_:
| 
    { [] }
| x = fun_exp_decl_statement_list
    { x }

loption_filespec_:
| 
    { [] }
| x = filespec
    { x }

loption_error_words_:
| 
    { [] }
| x = error_words
    { x }

list_whens_pre_post_decl_statement_or_expression_rule_elem_statement__:
| 
    { [] }
| x = whens_pre_post_decl_statement_or_expression_rule_elem_statement_ xs = list_whens_pre_post_decl_statement_or_expression_rule_elem_statement__
    { x :: xs }

list_pair_edots_when_TEllipsis_eexpr__dexpr__:
| 
    { [] }
| x0 = edots_when_TEllipsis_eexpr_ y0 = dexpr xs = list_pair_edots_when_TEllipsis_eexpr__dexpr__
    {let x =
  let y = y0 in
  let x = x0 in
  ( (x, y) )
in
 x :: xs }

list_pair_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__exp_decl_statement_list__:
| 
    { [] }
| x0 = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ y0 = exp_decl_statement_list xs = list_pair_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__exp_decl_statement_list__
    {let x =
  let y = y0 in
  let x = x0 in
  ( (x, y) )
in
 x :: xs }

list_mzl_statement__:
| 
    { [] }
| x = mzl_statement_ xs = list_mzl_statement__
    { x :: xs }

list_mzl_rule_elem_statement__:
| 
    { [] }
| x = mzl_rule_elem_statement_ xs = list_mzl_rule_elem_statement__
    { x :: xs }

list_mzl_expr__:
| 
    { [] }
| x = mzl_expr_ xs = list_mzl_expr__
    { x :: xs }

list_mzl_eexpr__:
| 
    { [] }
| x = mzl_eexpr_ xs = list_mzl_eexpr__
    { x :: xs }

list_mzl_ctype__:
| 
    { [] }
| x = mzl_ctype_ xs = list_mzl_ctype__
    { x :: xs }

list_iso_xstatement_dots_TEllipsis___:
| 
    { [] }
| x = iso_xstatement_dots_TEllipsis__ xs = list_iso_xstatement_dots_TEllipsis___
    { x :: xs }

minus_main:
| minus_body EOF
    { $1 }
| m = minus_body TArobArob
    { m }
| m = minus_body TArob
    { m }

metadec:
| ar = arity ispure = pure TIdentifier ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaIdDecl(arity,name)) in
      !Data.add_id_meta name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TFresh TIdentifier ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaFreshIdDecl(arity,name)) in
      !Data.add_id_meta name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TType ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaTypeDecl(arity,name)) in
      !Data.add_type_meta name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TParameter ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaParamDecl(arity,name)) in
      !Data.add_param_meta name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TParameter Tlist ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaParamListDecl(arity,name)) in
      !Data.add_paramlist_meta name pure; tok))
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TError ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaErrDecl(arity,name)) in
      !Data.add_err_meta name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TExpression ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaExpDecl(arity,name,None)) in
      !Data.add_exp_meta None name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TExpression Tlist ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaExpListDecl(arity,name)) in
      !Data.add_explist_meta name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TExpression m0 = nonempty_list_TMul_ ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  let m = m0 in
  ( (fun arity name pure check_meta ->
      let ty = Some [P.ty_pointerify Type_cocci.Unknown m] in
      let tok = check_meta(Ast.MetaExpDecl(arity,name,ty)) in
      !Data.add_exp_meta ty name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TStatement ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaStmDecl(arity,name)) in
      !Data.add_stm_meta name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TStatement Tlist ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaStmListDecl(arity,name)) in
      !Data.add_stmlist_meta name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TFunction ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaFuncDecl(arity,name)) in
      !Data.add_func_meta name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TLocal TFunction ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaLocalFuncDecl(arity,name)) in
      !Data.add_local_func_meta name pure;
      tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure vl0 = meta_exp_type ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  let vl = vl0 in
  ( (fun arity name pure check_meta ->
      let ty = Some vl in
      let tok = check_meta(Ast.MetaExpDecl(arity,name,ty)) in
      !Data.add_exp_meta ty name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure vl0 = meta_exp_type TOCro TCCro ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  let vl = vl0 in
  ( (fun arity name pure check_meta ->
      let ty = Some (List.map (function x -> Type_cocci.Array x) vl) in
      let tok = check_meta(Ast.MetaExpDecl(arity,name,ty)) in
      !Data.add_exp_meta ty name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TConstant ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  let ty =
    ( None )
  in
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaConstDecl(arity,name,ty)) in
      !Data.add_const_meta ty name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TConstant x00 = meta_exp_type ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  let x0 = x00 in
  let ty =
    let x = x0 in
    ( Some x )
  in
  ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaConstDecl(arity,name,ty)) in
      !Data.add_const_meta ty name pure; tok) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TTypedef ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity (_,name) pure check_meta ->
      if arity = Ast.NONE && pure = Ast0.Impure
      then (!Data.add_type_name name; [])
      else raise (Semantic_cocci.Semantic "bad typedef")) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }
| ar = arity ispure = pure TDeclarer ids = comma_list_pure_ident_or_meta_ident_ TMPtVirg
    {let kindfn =
  ( (fun arity (_,name) pure check_meta ->
      if arity = Ast.NONE && pure = Ast0.Impure
      then (!Data.add_declarer_name name; [])
      else raise (Semantic_cocci.Semantic "bad declarer")) )
in
 function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) }

meta_exp_type:
| t = ctype
    { [Ast0_cocci.ast0_type_to_type t] }
| TOBrace t = comma_list_ctype_ TCBrace m = list_TMul_
    { List.map
	(function x -> P.ty_pointerify (Ast0_cocci.ast0_type_to_type x) m)
	t }

struct_decl:
| t = ctype d = d_ident pv = TPtVirg
    { let (id,fn) = d in
	 Ast0.wrap(Ast0.UnInit(None,fn t,id,P.clt2mcode ";" pv)) }
| t = fn_ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar pv = TPtVirg
    { let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
        Ast0.wrap(Ast0.UnInit(None,fn t,id,P.clt2mcode ";" pv)) }
| i = pure_ident d = d_ident pv = TPtVirg
    {let cv =
  ( None )
in
 let (id,fn) = d in
	 let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	 Ast0.wrap(Ast0.UnInit(None,fn idtype,id,P.clt2mcode ";" pv)) }
| x0 = const_vol i = pure_ident d = d_ident pv = TPtVirg
    {let cv =
  let x = x0 in
  ( Some x )
in
 let (id,fn) = d in
	 let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	 Ast0.wrap(Ast0.UnInit(None,fn idtype,id,P.clt2mcode ";" pv)) }

struct_decl_list:
| struct_decl_list_start
    { Ast0.wrap(Ast0.DOTS($1)) }

struct_decl_list_start:
| struct_decl
    { [$1] }
| struct_decl struct_decl_list_start
    { $1::$2 }
| d = edots_when_TEllipsis_struct_decl_ r = continue_struct_decl_list
    { (P.mkddots "..." d)::r }

minus_body:
| f = loption_filespec_ i = list_includes_ b = loption_minus_function_decl_statement_or_expression_ ew = loption_error_words_
    { match f@i@b@ew with
      [] -> raise (Semantic_cocci.Semantic "minus slice can't be empty")
    | code -> Top_level.top_level code }

storage:
| s = Tstatic
    { P.clt2mcode Ast.Static s }
| s = Tauto
    { P.clt2mcode Ast.Auto s }
| s = Tregister
    { P.clt2mcode Ast.Register s }
| s = Textern
    { P.clt2mcode Ast.Extern s }

name_opt_decl:
| decl
    { $1 }
| t = ctype
    { Ast0.wrap(Ast0.Param(t, None)) }
| t = fn_ctype lp = TOPar s = TMul rp = TCPar lp1 = TOPar d = decl_list_name_opt_decl_ rp1 = TCPar
    { let fnptr =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp,P.clt2mcode "*" s,P.clt2mcode ")" rp,
		P.clt2mcode "(" lp1,d,P.clt2mcode ")" rp1)) in
	Ast0.wrap(Ast0.Param(fnptr, None)) }

statement:
| TMetaStm
    { P.meta_stm $1 }
| expr TPtVirg
    { P.exp_stm $1 $2 }
| TIf TOPar eexpr TCPar single_statement %prec TIf
    { P.ifthen $1 $2 $3 $4 $5 }
| TIf TOPar eexpr TCPar single_statement TElse single_statement
    { P.ifthenelse $1 $2 $3 $4 $5 $6 $7 }
| TFor TOPar option_eexpr_ TPtVirg option_eexpr_ TPtVirg option_eexpr_ TCPar single_statement
    { P.forloop $1 $2 $3 $4 $5 $6 $7 $8 $9 }
| TWhile TOPar eexpr TCPar single_statement
    { P.whileloop $1 $2 $3 $4 $5 }
| TDo single_statement TWhile TOPar eexpr TCPar TPtVirg
    { P.doloop $1 $2 $3 $4 $5 $6 $7 }
| TSwitch TOPar eexpr TCPar TOBrace list_case_line_ TCBrace
    { P.switch $1 $2 $3 $4 $5 $6 $7 }
| TReturn eexpr TPtVirg
    { P.ret_exp $1 $2 $3 }
| TReturn TPtVirg
    { P.ret $1 $2 }
| TBreak TPtVirg
    { P.break $1 $2 }
| TContinue TPtVirg
    { P.cont $1 $2 }
| TOBrace pre_post_decl_statement_and_expression_opt TCBrace
    { P.seq $1 $2 $3 }
| TOEllipsis w = option_whenppdecs_ b = statement_dots_TEllipsis_ c = TCEllipsis
    { Ast0.wrap(Ast0.Nest(P.clt2mcode "<..." $1,
			  Ast0.wrap(Ast0.DOTS(b (P.mkdots "..."))),
			  P.clt2mcode "...>" c, w)) }

whenppdecs:
| TWhen TNotEq w = pre_post_decl_statement_or_expression TLineEnd
    { w }

statement_dots_TEllipsis_:
| r = no_dot_start_end_exp_decl_statement_list_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__
    { function dot_builder ->
    List.concat (r (function x -> [dot_builder x])) }

single_statement:
| statement
    { $1 }
| TOPar0 midzero_list_statement_ TCPar0
    { let (mids,code) = $2 in
        Ast0.wrap
	  (Ast0.Disj(P.clt2mcode "(" $1,
		     List.map (function x -> Ast0.wrap(Ast0.DOTS([x]))) code,
		     mids, P.clt2mcode ")" $3)) }

nest_expressions:
| TOEllipsis w = option_whenexp_ e = expr_dots_TEllipsis_ c = TCEllipsis
    { Ast0.wrap(Ast0.NestExpr(P.clt2mcode "<..." $1,
			      Ast0.wrap(Ast0.DOTS(e (P.mkedots "..."))),
			      P.clt2mcode "...>" c, w)) }

whenexp:
| TWhen TNotEq w = eexpr TLineEnd
    { w }

separated_nonempty_list_TComma_pure_ident_or_meta_ident_:
| x = pure_ident_or_meta_ident
    { [ x ] }
| x = pure_ident_or_meta_ident TComma xs = separated_nonempty_list_TComma_pure_ident_or_meta_ident_
    { x :: xs }

separated_nonempty_list_TComma_dexpr_:
| x = dexpr
    { [ x ] }
| x = dexpr TComma xs = separated_nonempty_list_TComma_dexpr_
    { x :: xs }

separated_nonempty_list_TComma_d_ident_:
| x = d_ident
    { [ x ] }
| x = d_ident TComma xs = separated_nonempty_list_TComma_d_ident_
    { x :: xs }

separated_nonempty_list_TComma_ctype_:
| x = ctype
    { [ x ] }
| x = ctype TComma xs = separated_nonempty_list_TComma_ctype_
    { x :: xs }

separated_nonempty_list_TAndLog_pnrule_:
| x = pnrule
    { [ x ] }
| x = pnrule TAndLog xs = separated_nonempty_list_TAndLog_pnrule_
    { x :: xs }

plus_main:
| plus_body EOF
    { $1 }
| p = plus_body TArobArob
    { p }
| p = plus_body TArob
    { p }

iso_meta_main:
| m = metadec
    { m "" }

pure:
| TPure
    { Ast0.Pure }
| TContext
    { Ast0.Context }
| 
    { Ast0.Impure }

rule_name:
| nm = pure_ident extends d = depends TArob
    {let i =
  ( None )
in
 let n = P.id2name nm in
    (try let _ =  Hashtbl.find Data.all_metadecls n in
    raise (Semantic_cocci.Semantic ("repeated rule name"))
    with Not_found -> ());
    (n,d,i) }
| nm = pure_ident extends d = depends x0 = choose_iso TArob
    {let i =
  let x = x0 in
  ( Some x )
in
 let n = P.id2name nm in
    (try let _ =  Hashtbl.find Data.all_metadecls n in
    raise (Semantic_cocci.Semantic ("repeated rule name"))
    with Not_found -> ());
    (n,d,i) }

extends:
| 
    { () }
| TExtends parent = TRuleName
    { !Data.install_bindings (parent) }

depends:
| 
    { [] }
| TDepends TOn parents = separated_nonempty_list_TAndLog_pnrule_
    { parents }

pnrule:
| TRuleName
    { Ast.Dep $1 }
| TBang TRuleName
    { Ast.AntiDep $2 }

choose_iso:
| TUsing TString
    { P.id2name $2 }

arity:
| TBang0
    { Ast.UNIQUE }
| TWhy0
    { Ast.OPT }
| TPlus0
    { Ast.MULTI }
| 
    { Ast.NONE }

generic_ctype:
| q = ctype_qualif
    { Ast0.wrap(Ast0.ImplicitInt(q)) }
| ty = Tchar
    {let q =
  ( None )
in
 Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.CharType ty, q)) }
| x0 = ctype_qualif ty = Tchar
    {let q =
  let x = x0 in
  ( Some x )
in
 Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.CharType ty, q)) }
| ty = Tshort
    {let q =
  ( None )
in
 Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.ShortType ty, q)) }
| x0 = ctype_qualif ty = Tshort
    {let q =
  let x = x0 in
  ( Some x )
in
 Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.ShortType ty, q)) }
| ty = Tint
    {let q =
  ( None )
in
 Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.IntType ty, q)) }
| x0 = ctype_qualif ty = Tint
    {let q =
  let x = x0 in
  ( Some x )
in
 Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.IntType ty, q)) }
| t = Tdouble
    { Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.DoubleType t, None)) }
| t = Tfloat
    { Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.FloatType t, None)) }
| ty = Tlong
    {let q =
  ( None )
in
 Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.LongType ty, q)) }
| x0 = ctype_qualif ty = Tlong
    {let q =
  let x = x0 in
  ( Some x )
in
 Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.LongType ty, q)) }
| s = struct_or_union i = ident
    { Ast0.wrap(Ast0.StructUnionName(s, i)) }
| s = struct_or_union i = ident l = TOBrace d = struct_decl_list r = TCBrace
    { Ast0.wrap(Ast0.StructUnionDef(Ast0.wrap(Ast0.StructUnionName(s, i)),
					 P.clt2mcode "{" l,
					 d, P.clt2mcode "}" r)) }
| s = TMetaType l = TOBrace d = struct_decl_list r = TCBrace
    { let (nm,pure,clt) = s in
	 let ty = Ast0.wrap(Ast0.MetaType(P.clt2mcode nm clt,pure)) in
	 Ast0.wrap
	   (Ast0.StructUnionDef(ty,P.clt2mcode "{" l,d,P.clt2mcode "}" r)) }
| r = TRuleName TDot p = TIdent
    { let nm = (r,P.id2name p) in
	 (* this is only possible when we are in a metavar decl.  Otherwise,
	    it will be represented already as a MetaType *)
	 let _ = P.check_meta(Ast.MetaTypeDecl(Ast.NONE,nm)) in
	 Ast0.wrap(Ast0.MetaType(P.clt2mcode nm (P.id2clt p),
				 Ast0.Impure (*will be ignored*))) }
| p = TTypeId
    { Ast0.wrap(Ast0.TypeName(P.id2mcode p)) }
| p = TMetaType
    { let (nm,pure,clt) = p in
	 Ast0.wrap(Ast0.MetaType(P.clt2mcode nm clt,pure)) }

continue_struct_decl_list:
| 
    { [] }
| struct_decl struct_decl_list_start
    { $1::$2 }
| struct_decl
    { [$1] }

ctype:
| ty = generic_ctype m = list_TMul_
    {let cv =
  ( None )
in
 P.pointerify (P.make_cv cv ty) m }
| x0 = const_vol ty = generic_ctype m = list_TMul_
    {let cv =
  let x = x0 in
  ( Some x )
in
 P.pointerify (P.make_cv cv ty) m }
| t = Tvoid m = nonempty_list_TMul_
    {let cv =
  ( None )
in
 let ty =
	     Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.VoidType t, None)) in
	   P.pointerify (P.make_cv cv ty) m }
| x0 = const_vol t = Tvoid m = nonempty_list_TMul_
    {let cv =
  let x = x0 in
  ( Some x )
in
 let ty =
	     Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.VoidType t, None)) in
	   P.pointerify (P.make_cv cv ty) m }

fn_ctype:
| ty = generic_ctype m = list_TMul_
    { P.pointerify ty m }
| t = Tvoid m = list_TMul_
    { P.pointerify
	     (Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.VoidType t, None)))
	     m }

ctype_qualif:
| Tunsigned
    { P.clt2mcode Ast.Unsigned $1 }
| Tsigned
    { P.clt2mcode Ast.Signed $1 }

plus_body:
| f = loption_filespec_ i = list_includes_ b = loption_plus_function_decl_statement_or_expression_ ew = loption_error_words_
    { Top_level.top_level (f@i@b@ew) }

filespec:
| TMinusFile TPlusFile
    { [Ast0.wrap
	  (Ast0.FILEINFO(P.id2mcode $1,
			 P.id2mcode $2))] }

list_iso_single_statement__:
| 
    { [] }
| x = iso_single_statement_ xs = list_iso_single_statement__
    { x :: xs }

list_iso_dexpr__:
| 
    { [] }
| x = iso_dexpr_ xs = list_iso_dexpr__
    { x :: xs }

list_iso_decl_var__:
| 
    { [] }
| x = iso_decl_var_ xs = list_iso_decl_var__
    { x :: xs }

list_iso_ctype__:
| 
    { [] }
| x = iso_ctype_ xs = list_iso_ctype__
    { x :: xs }

list_includes_:
| 
    { [] }
| x = includes xs = list_includes_
    { x :: xs }

list_dp_comma_args_TEllipsis__:
| 
    { [] }
| x = dp_comma_args_TEllipsis_ xs = list_dp_comma_args_TEllipsis__
    { x :: xs }

list_comma_decls_TEllipsis_name_opt_decl__:
| 
    { [] }
| x = comma_decls_TEllipsis_name_opt_decl_ xs = list_comma_decls_TEllipsis_name_opt_decl__
    { x :: xs }

list_comma_decls_TEllipsis_decl__:
| 
    { [] }
| x = comma_decls_TEllipsis_decl_ xs = list_comma_decls_TEllipsis_decl__
    { x :: xs }

list_comma_args_edots_when_TEllipsis_eexpr___:
| 
    { [] }
| x = comma_args_edots_when_TEllipsis_eexpr__ xs = list_comma_args_edots_when_TEllipsis_eexpr___
    { x :: xs }

list_case_line_:
| 
    { [] }
| x = case_line xs = list_case_line_
    { x :: xs }

list_array_dec_:
| 
    { [] }
| x = array_dec xs = list_array_dec_
    { x :: xs }

list_TMul_:
| 
    { [] }
| x = TMul xs = list_TMul_
    { x :: xs }

includes:
| TIncludeL
    { Ast0.wrap
	(Ast0.DECL
	   (Ast0.wrap
	      (Ast0.Include(P.clt2mcode "#include" (P.drop_aft (P.id2clt $1)),
			    let (arity,ln,lln,offset,col,strbef,straft) =
			      P.id2clt $1 in
			    let clt = (arity,ln,lln,offset,0,strbef,straft) in
			    P.clt2mcode
			      (Ast.Local (Parse_aux.str2inc (P.id2name $1)))
			      (P.drop_bef clt))))) }
| TIncludeNL
    { Ast0.wrap
	(Ast0.DECL
	   (Ast0.wrap
	      (Ast0.Include(P.clt2mcode "#include" (P.drop_aft (P.id2clt $1)),
			    let (arity,ln,lln,offset,col,strbef,straft) =
			      P.id2clt $1 in
			    let clt = (arity,ln,lln,offset,0,strbef,straft) in
			    P.clt2mcode
			      (Ast.NonLocal (Parse_aux.str2inc (P.id2name $1)))
			      (P.drop_bef clt))))) }
| d = defineop t = ctype
    { let ty = Ast0.wrap(Ast0.Ty(t)) in
      Ast0.wrap(Ast0.DECL(d (Ast0.wrap(Ast0.DOTS([ty]))))) }
| defineop b = statement_dots_TEllipsis_
    { Ast0.wrap
	(Ast0.DECL
	   ($1 (Ast0.wrap(Ast0.DOTS(b (P.mkdots "...")))))) }

defineop:
| TDefine
    { let (clt,ident) = $1 in
      function body ->
	Ast0.wrap
	  (Ast0.Define(P.clt2mcode "#define" clt,
		       (match ident with
			 TMetaId((nm,pure,clt)) ->
			   Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,pure))
		       | TIdent(nm_pure) ->
			   Ast0.wrap(Ast0.Id(P.id2mcode nm_pure))
		       | _ ->
			   raise
			     (Semantic_cocci.Semantic
				"unexpected name for a #define")),
		       Ast0.wrap Ast0.NoParams,
		       body)) }
| TDefineParam define_param_list_option TCPar
    { let (clt,ident,parenoff) = $1 in
      let (arity,line,lline,offset,col,strbef,straft) = clt in
      let lp = P.clt2mcode "(" (arity,line,lline,parenoff,0,[],[]) in
      function body ->
	Ast0.wrap
	  (Ast0.Define
	     (P.clt2mcode "#define" clt,
	      (match ident with
		TMetaId((nm,pure,clt)) ->
		  Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,pure))
	      | TIdent(nm_pure) ->
		  Ast0.wrap(Ast0.Id(P.id2mcode nm_pure))
	      | _ ->
		  raise
		    (Semantic_cocci.Semantic
		       "unexpected name for a #define")),
	      Ast0.wrap (Ast0.DParams (lp,$2,P.clt2mcode ")" $3)),body)) }

define_param_list:
| define_param_list_start
    {let circle x =
       match Ast0.unwrap x with Ast0.DPcircles(_) -> true | _ -> false in
     if List.exists circle $1
     then Ast0.wrap(Ast0.CIRCLES($1))
     else Ast0.wrap(Ast0.DOTS($1)) }

define_param_list_start:
| ident
    { [Ast0.wrap(Ast0.DParam $1)] }
| ident TComma define_param_list_start
    { Ast0.wrap(Ast0.DParam $1)::
	Ast0.wrap(Ast0.DPComma(P.clt2mcode "," $2))::$3 }
| d = TEllipsis r = list_dp_comma_args_TEllipsis__
    { (P.mkdpdots "..." d)::
	(List.concat (List.map (function x -> x (P.mkdpdots "...")) r)) }

dp_comma_args_TEllipsis_:
| c = TComma d = TEllipsis
    { function dot_builder ->
      [Ast0.wrap(Ast0.DPComma(P.clt2mcode "," c)); dot_builder d] }
| TComma ident
    { function dot_builder ->
      [Ast0.wrap(Ast0.DPComma(P.clt2mcode "," $1));
	Ast0.wrap(Ast0.DParam $2)] }

define_param_list_option:
| define_param_list
    { $1 }
| 
    { Ast0.wrap(Ast0.DOTS([])) }

funproto:
| t = ctype id = func_ident lp = TOPar d = decl_list_decl_ rp = TCPar pt = TPtVirg
    {let s =
  ( None )
in
 Ast0.wrap
	  (Ast0.UnInit
	     (s,
	      Ast0.wrap
		(Ast0.FunctionType(Some t,
				   P.clt2mcode "(" lp, d, P.clt2mcode ")" rp)),
	      id, P.clt2mcode ";" pt)) }
| x0 = storage t = ctype id = func_ident lp = TOPar d = decl_list_decl_ rp = TCPar pt = TPtVirg
    {let s =
  let x = x0 in
  ( Some x )
in
 Ast0.wrap
	  (Ast0.UnInit
	     (s,
	      Ast0.wrap
		(Ast0.FunctionType(Some t,
				   P.clt2mcode "(" lp, d, P.clt2mcode ")" rp)),
	      id, P.clt2mcode ";" pt)) }
| t = Tvoid id = func_ident lp = TOPar d = decl_list_decl_ rp = TCPar pt = TPtVirg
    {let s =
  ( None )
in
 let t = Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.VoidType t, None)) in
      Ast0.wrap
        (Ast0.UnInit
	   (s,
	    Ast0.wrap
	      (Ast0.FunctionType(Some t,
				 P.clt2mcode "(" lp, d, P.clt2mcode ")" rp)),
	    id, P.clt2mcode ";" pt)) }
| x0 = storage t = Tvoid id = func_ident lp = TOPar d = decl_list_decl_ rp = TCPar pt = TPtVirg
    {let s =
  let x = x0 in
  ( Some x )
in
 let t = Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.VoidType t, None)) in
      Ast0.wrap
        (Ast0.UnInit
	   (s,
	    Ast0.wrap
	      (Ast0.FunctionType(Some t,
				 P.clt2mcode "(" lp, d, P.clt2mcode ")" rp)),
	    id, P.clt2mcode ";" pt)) }

fundecl:
| f = fninfo TFunDecl i = func_ident lp = TOPar d = decl_list_decl_ rp = TCPar lb = TOBrace b = pre_post_decl_statement_and_expression_opt rb = TCBrace
    { Ast0.wrap(Ast0.FunDecl((Ast0.default_info(),Ast0.context_befaft()),
			       f, i,
			       P.clt2mcode "(" lp, d,
			       P.clt2mcode ")" rp,
			       P.clt2mcode "{" lb, b,
			       P.clt2mcode "}" rb)) }

postfix_expr_expr_invalid_:
| primary_expr_expr_invalid_
    { $1 }
| postfix_expr_expr_invalid_ TOCro eexpr TCCro
    { Ast0.wrap(Ast0.ArrayAccess ($1,P.clt2mcode "[" $2,$3,
				       P.clt2mcode "]" $4)) }
| postfix_expr_expr_invalid_ TDot ident
    { Ast0.wrap(Ast0.RecordAccess($1, P.clt2mcode "." $2, $3)) }
| postfix_expr_expr_invalid_ TPtrOp ident
    { Ast0.wrap(Ast0.RecordPtAccess($1, P.clt2mcode "->" $2,
				     $3)) }
| postfix_expr_expr_invalid_ TInc
    { Ast0.wrap(Ast0.Postfix ($1, P.clt2mcode Ast.Inc $2)) }
| postfix_expr_expr_invalid_ TDec
    { Ast0.wrap(Ast0.Postfix ($1, P.clt2mcode Ast.Dec $2)) }
| postfix_expr_expr_invalid_ TOPar eexpr_list_option TCPar
    { Ast0.wrap(Ast0.FunCall($1,P.clt2mcode "(" $2,$3,
			      P.clt2mcode ")" $4)) }

postfix_expr_eexpr_nest_expressions_:
| primary_expr_eexpr_nest_expressions_
    { $1 }
| postfix_expr_eexpr_nest_expressions_ TOCro eexpr TCCro
    { Ast0.wrap(Ast0.ArrayAccess ($1,P.clt2mcode "[" $2,$3,
				       P.clt2mcode "]" $4)) }
| postfix_expr_eexpr_nest_expressions_ TDot ident
    { Ast0.wrap(Ast0.RecordAccess($1, P.clt2mcode "." $2, $3)) }
| postfix_expr_eexpr_nest_expressions_ TPtrOp ident
    { Ast0.wrap(Ast0.RecordPtAccess($1, P.clt2mcode "->" $2,
				     $3)) }
| postfix_expr_eexpr_nest_expressions_ TInc
    { Ast0.wrap(Ast0.Postfix ($1, P.clt2mcode Ast.Inc $2)) }
| postfix_expr_eexpr_nest_expressions_ TDec
    { Ast0.wrap(Ast0.Postfix ($1, P.clt2mcode Ast.Dec $2)) }
| postfix_expr_eexpr_nest_expressions_ TOPar eexpr_list_option TCPar
    { Ast0.wrap(Ast0.FunCall($1,P.clt2mcode "(" $2,$3,
			      P.clt2mcode ")" $4)) }

postfix_expr_eexpr_invalid_:
| primary_expr_eexpr_invalid_
    { $1 }
| postfix_expr_eexpr_invalid_ TOCro eexpr TCCro
    { Ast0.wrap(Ast0.ArrayAccess ($1,P.clt2mcode "[" $2,$3,
				       P.clt2mcode "]" $4)) }
| postfix_expr_eexpr_invalid_ TDot ident
    { Ast0.wrap(Ast0.RecordAccess($1, P.clt2mcode "." $2, $3)) }
| postfix_expr_eexpr_invalid_ TPtrOp ident
    { Ast0.wrap(Ast0.RecordPtAccess($1, P.clt2mcode "->" $2,
				     $3)) }
| postfix_expr_eexpr_invalid_ TInc
    { Ast0.wrap(Ast0.Postfix ($1, P.clt2mcode Ast.Inc $2)) }
| postfix_expr_eexpr_invalid_ TDec
    { Ast0.wrap(Ast0.Postfix ($1, P.clt2mcode Ast.Dec $2)) }
| postfix_expr_eexpr_invalid_ TOPar eexpr_list_option TCPar
    { Ast0.wrap(Ast0.FunCall($1,P.clt2mcode "(" $2,$3,
			      P.clt2mcode ")" $4)) }

postfix_expr_eexpr_dot_expressions_:
| primary_expr_eexpr_dot_expressions_
    { $1 }
| postfix_expr_eexpr_dot_expressions_ TOCro eexpr TCCro
    { Ast0.wrap(Ast0.ArrayAccess ($1,P.clt2mcode "[" $2,$3,
				       P.clt2mcode "]" $4)) }
| postfix_expr_eexpr_dot_expressions_ TDot ident
    { Ast0.wrap(Ast0.RecordAccess($1, P.clt2mcode "." $2, $3)) }
| postfix_expr_eexpr_dot_expressions_ TPtrOp ident
    { Ast0.wrap(Ast0.RecordPtAccess($1, P.clt2mcode "->" $2,
				     $3)) }
| postfix_expr_eexpr_dot_expressions_ TInc
    { Ast0.wrap(Ast0.Postfix ($1, P.clt2mcode Ast.Inc $2)) }
| postfix_expr_eexpr_dot_expressions_ TDec
    { Ast0.wrap(Ast0.Postfix ($1, P.clt2mcode Ast.Dec $2)) }
| postfix_expr_eexpr_dot_expressions_ TOPar eexpr_list_option TCPar
    { Ast0.wrap(Ast0.FunCall($1,P.clt2mcode "(" $2,$3,
			      P.clt2mcode ")" $4)) }

primary_expr_expr_invalid_:
| func_ident
    { Ast0.wrap(Ast0.Ident($1)) }
| TInt
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) }
| TFloat
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Float x) clt)) }
| TString
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.String x) clt)) }
| TChar
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Char x) clt)) }
| TMetaConst
    { let (nm,pure,ty,clt) = $1 in
     Ast0.wrap(Ast0.MetaConst(P.clt2mcode nm clt,ty,pure)) }
| TMetaErr
    { let (nm,pure,clt) = $1 in
     Ast0.wrap(Ast0.MetaErr(P.clt2mcode nm clt,pure)) }
| TMetaExp
    { let (nm,pure,ty,clt) = $1 in
     Ast0.wrap(Ast0.MetaExpr(P.clt2mcode nm clt,ty,pure)) }
| TOPar eexpr TCPar
    { Ast0.wrap(Ast0.Paren(P.clt2mcode "(" $1,$2,
			    P.clt2mcode ")" $3)) }
| TOPar0 midzero_list_expr_ TCPar0
    { let (mids,code) = $2 in
       Ast0.wrap(Ast0.DisjExpr(P.clt2mcode "(" $1,
			       code, mids,
			       P.clt2mcode ")" $3)) }
| invalid
    { $1 }

primary_expr_eexpr_nest_expressions_:
| func_ident
    { Ast0.wrap(Ast0.Ident($1)) }
| TInt
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) }
| TFloat
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Float x) clt)) }
| TString
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.String x) clt)) }
| TChar
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Char x) clt)) }
| TMetaConst
    { let (nm,pure,ty,clt) = $1 in
     Ast0.wrap(Ast0.MetaConst(P.clt2mcode nm clt,ty,pure)) }
| TMetaErr
    { let (nm,pure,clt) = $1 in
     Ast0.wrap(Ast0.MetaErr(P.clt2mcode nm clt,pure)) }
| TMetaExp
    { let (nm,pure,ty,clt) = $1 in
     Ast0.wrap(Ast0.MetaExpr(P.clt2mcode nm clt,ty,pure)) }
| TOPar eexpr TCPar
    { Ast0.wrap(Ast0.Paren(P.clt2mcode "(" $1,$2,
			    P.clt2mcode ")" $3)) }
| TOPar0 midzero_list_eexpr_ TCPar0
    { let (mids,code) = $2 in
       Ast0.wrap(Ast0.DisjExpr(P.clt2mcode "(" $1,
			       code, mids,
			       P.clt2mcode ")" $3)) }
| nest_expressions
    { $1 }

primary_expr_eexpr_invalid_:
| func_ident
    { Ast0.wrap(Ast0.Ident($1)) }
| TInt
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) }
| TFloat
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Float x) clt)) }
| TString
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.String x) clt)) }
| TChar
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Char x) clt)) }
| TMetaConst
    { let (nm,pure,ty,clt) = $1 in
     Ast0.wrap(Ast0.MetaConst(P.clt2mcode nm clt,ty,pure)) }
| TMetaErr
    { let (nm,pure,clt) = $1 in
     Ast0.wrap(Ast0.MetaErr(P.clt2mcode nm clt,pure)) }
| TMetaExp
    { let (nm,pure,ty,clt) = $1 in
     Ast0.wrap(Ast0.MetaExpr(P.clt2mcode nm clt,ty,pure)) }
| TOPar eexpr TCPar
    { Ast0.wrap(Ast0.Paren(P.clt2mcode "(" $1,$2,
			    P.clt2mcode ")" $3)) }
| TOPar0 midzero_list_eexpr_ TCPar0
    { let (mids,code) = $2 in
       Ast0.wrap(Ast0.DisjExpr(P.clt2mcode "(" $1,
			       code, mids,
			       P.clt2mcode ")" $3)) }
| invalid
    { $1 }

primary_expr_eexpr_dot_expressions_:
| func_ident
    { Ast0.wrap(Ast0.Ident($1)) }
| TInt
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) }
| TFloat
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Float x) clt)) }
| TString
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.String x) clt)) }
| TChar
    { let (x,clt) = $1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Char x) clt)) }
| TMetaConst
    { let (nm,pure,ty,clt) = $1 in
     Ast0.wrap(Ast0.MetaConst(P.clt2mcode nm clt,ty,pure)) }
| TMetaErr
    { let (nm,pure,clt) = $1 in
     Ast0.wrap(Ast0.MetaErr(P.clt2mcode nm clt,pure)) }
| TMetaExp
    { let (nm,pure,ty,clt) = $1 in
     Ast0.wrap(Ast0.MetaExpr(P.clt2mcode nm clt,ty,pure)) }
| TOPar eexpr TCPar
    { Ast0.wrap(Ast0.Paren(P.clt2mcode "(" $1,$2,
			    P.clt2mcode ")" $3)) }
| TOPar0 midzero_list_eexpr_ TCPar0
    { let (mids,code) = $2 in
       Ast0.wrap(Ast0.DisjExpr(P.clt2mcode "(" $1,
			       code, mids,
			       P.clt2mcode ")" $3)) }
| dot_expressions
    { $1 }

pure_ident:
| TIdent
    { $1 }

pure_ident_or_meta_ident:
| pure_ident
    { (None,P.id2name $1) }
| TRuleName TDot pure_ident
    { (Some $1,P.id2name $3) }

one_dec_name_opt_decl_:
| name_opt_decl
    { $1 }
| TMetaParamList
    { let (nm,pure,clt) = $1 in
    Ast0.wrap(Ast0.MetaParamList(P.clt2mcode nm clt,pure)) }

one_dec_decl_:
| decl
    { $1 }
| TMetaParamList
    { let (nm,pure,clt) = $1 in
    Ast0.wrap(Ast0.MetaParamList(P.clt2mcode nm clt,pure)) }

pure_decl_statement_list:
| nonempty_list_decl_statement_
    { List.concat $1 }

minus_function_decl_statement_or_expression:
| opt_dot_start_end_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    { List.concat
	($1 (function x -> function y ->
	      [Ast0.wrap(Ast0.OTHER (P.mkdots x y))])) }

plus_function_decl_statement_or_expression:
| first = fun_exp_decl_statement_list
    { first }
| first = loption_fun_exp_decl_statement_list_ second = required_dot_start_with_ender_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    { List.concat
	   (first ::
	    (second
	       (function x -> function y ->
		 [Ast0.wrap(Ast0.OTHER (P.mkdots x y))]))) }

pre_post_decl_statement_or_expression:
| opt_dot_start_end_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list_
    { P.top_dots(List.concat ($1 (function x -> function y -> [P.mkdots x y]))) }

pre_post_decl_statement_and_expression:
| first = pure_decl_statement_list
    { P.top_dots first }
| first = loption_pure_decl_statement_list_ second = required_dot_start_with_ender_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_pure_decl_statement_list_
    { P.top_dots
	  (List.concat
	     (first::(second (function x -> function y -> [P.mkdots x y])))) }

pre_post_decl_statement_and_expression_opt:
| 
    { Ast0.wrap(Ast0.DOTS([])) }
| pre_post_decl_statement_and_expression
    { $1 }

midzero_list_statement_:
| a = statement b = list_mzl_statement__
    { let (mids,code) = List.split b in (mids,(a::code)) }

midzero_list_rule_elem_statement_:
| a = rule_elem_statement b = list_mzl_rule_elem_statement__
    { let (mids,code) = List.split b in (mids,(a::code)) }

midzero_list_expr_:
| a = expr b = list_mzl_expr__
    { let (mids,code) = List.split b in (mids,(a::code)) }

midzero_list_eexpr_:
| a = eexpr b = list_mzl_eexpr__
    { let (mids,code) = List.split b in (mids,(a::code)) }

midzero_list_ctype_:
| a = ctype b = list_mzl_ctype__
    { let (mids,code) = List.split b in (mids,(a::code)) }

mzl_statement_:
| a = TMid0 b = statement
    { (P.clt2mcode "|" a, b) }

mzl_rule_elem_statement_:
| a = TMid0 b = rule_elem_statement
    { (P.clt2mcode "|" a, b) }

mzl_expr_:
| a = TMid0 b = expr
    { (P.clt2mcode "|" a, b) }

mzl_eexpr_:
| a = TMid0 b = eexpr
    { (P.clt2mcode "|" a, b) }

mzl_ctype_:
| a = TMid0 b = ctype
    { (P.clt2mcode "|" a, b) }

opt_dot_start_end_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_:
| start = fun_exp_decl_statement_list
    { function dot_builder -> [start] }
| r = opt_dot_start_end_pattern_fun_exp_decl_statement_list_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__fun_exp_decl_statement_list_opt_dot_end_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list__
    { function dot_builder -> r (dot_builder "...") }

opt_dot_start_end_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list_:
| start = exp_decl_statement_list
    { function dot_builder -> [start] }
| r = opt_dot_start_end_pattern_exp_decl_statement_list_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__exp_decl_statement_list_opt_dot_end_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list__
    { function dot_builder -> r (dot_builder "...") }

required_dot_start_with_ender_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_:
| start = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ finish = no_dot_start_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    { (function dot_builder ->
       (dot_builder "..." start) :: (finish (dot_builder "..."))) }

required_dot_start_with_ender_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_pure_decl_statement_list_:
| start = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ finish = no_dot_start_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_pure_decl_statement_list_
    { (function dot_builder ->
       (dot_builder "..." start) :: (finish (dot_builder "..."))) }

option_whenppdecs_:
| 
    { None }
| x = whenppdecs
    { Some x }

option_whenexp_:
| 
    { None }
| x = whenexp
    { Some x }

nonempty_list_fun_decl_statement_:
| x = fun_decl_statement
    { [ x ] }
| x = fun_decl_statement xs = nonempty_list_fun_decl_statement_
    { x :: xs }

nonempty_list_decl_statement_:
| x = decl_statement
    { [ x ] }
| x = decl_statement xs = nonempty_list_decl_statement_
    { x :: xs }

nonempty_list_TMul_:
| x = TMul
    { [ x ] }
| x = TMul xs = nonempty_list_TMul_
    { x :: xs }

fninfo:
| 
    { [] }
| storage fninfo
    { try
	let _ =
	  List.find (function Ast0.FStorage(_) -> true | _ -> false) $2 in
	raise (Semantic_cocci.Semantic "duplicate storage")
      with Not_found -> (Ast0.FStorage($1))::$2 }
| t = fn_ctype r = fninfo_nt
    { (Ast0.FType(t))::r }
| Tinline fninfo
    { try
	let _ = List.find (function Ast0.FInline(_) -> true | _ -> false) $2 in
	raise (Semantic_cocci.Semantic "duplicate inline")
      with Not_found -> (Ast0.FInline(P.clt2mcode "inline" $1))::$2 }
| Tattr fninfo
    { try
	let _ = List.find (function Ast0.FAttr(_) -> true | _ -> false) $2 in
	raise (Semantic_cocci.Semantic "multiple attributes")
      with Not_found -> (Ast0.FAttr(P.id2mcode $1))::$2 }

fninfo_nt:
| 
    { [] }
| storage fninfo_nt
    { try
	let _ =
	  List.find (function Ast0.FStorage(_) -> true | _ -> false) $2 in
	raise (Semantic_cocci.Semantic "duplicate storage")
      with Not_found -> (Ast0.FStorage($1))::$2 }
| Tinline fninfo_nt
    { try
	let _ = List.find (function Ast0.FInline(_) -> true | _ -> false) $2 in
	raise (Semantic_cocci.Semantic "duplicate inline")
      with Not_found -> (Ast0.FInline(P.clt2mcode "inline" $1))::$2 }
| Tattr fninfo_nt
    { try
	let _ = List.find (function Ast0.FAttr(_) -> true | _ -> false) $2 in
	raise (Semantic_cocci.Semantic "duplicate init")
      with Not_found -> (Ast0.FAttr(P.id2mcode $1))::$2 }

decl:
| t = ctype i = ident
    { Ast0.wrap(Ast0.Param(t, Some i)) }
| t = fn_ctype lp = TOPar s = TMul i = ident rp = TCPar lp1 = TOPar d = decl_list_name_opt_decl_ rp1 = TCPar
    { let fnptr =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp,P.clt2mcode "*" s,P.clt2mcode ")" rp,
		P.clt2mcode "(" lp1,d,P.clt2mcode ")" rp1)) in
	Ast0.wrap(Ast0.Param(fnptr, Some i)) }
| t = Tvoid
    { let ty = Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.VoidType t, None)) in
          Ast0.wrap(Ast0.VoidParam(ty)) }
| TMetaParam
    { let (nm,pure,clt) = $1 in
	Ast0.wrap(Ast0.MetaParam(P.clt2mcode nm clt,pure)) }

const_vol:
| Tconst
    { P.clt2mcode Ast.Const $1 }
| Tvolatile
    { P.clt2mcode Ast.Volatile $1 }

rule_elem_statement:
| expr TPtVirg
    { P.exp_stm $1 $2 }
| TReturn eexpr TPtVirg
    { P.ret_exp $1 $2 $3 }
| TReturn TPtVirg
    { P.ret $1 $2 }
| TBreak TPtVirg
    { P.break $1 $2 }
| TContinue TPtVirg
    { P.cont $1 $2 }
| TOPar0 midzero_list_rule_elem_statement_ TCPar0
    { let (mids,code) = $2 in
    Ast0.wrap
      (Ast0.Disj(P.clt2mcode "(" $1,
		 List.map (function x -> Ast0.wrap(Ast0.DOTS([x]))) code,
		 mids, P.clt2mcode ")" $3)) }

case_line:
| TDefault TDotDot pre_post_decl_statement_and_expression_opt
    { Ast0.wrap(Ast0.Default(P.clt2mcode "default" $1,P.clt2mcode ":" $2,$3)) }
| TCase eexpr TDotDot pre_post_decl_statement_and_expression_opt
    { Ast0.wrap(Ast0.Case(P.clt2mcode "case" $1,$2,P.clt2mcode ":" $3,$4)) }

decl_var:
| t = ctype pv = TPtVirg
    { [Ast0.wrap(Ast0.TyDecl(t,P.clt2mcode ";" pv))] }
| t = ctype d = comma_list_d_ident_ pv = TPtVirg
    {let s =
  ( None )
in
 List.map
	  (function (id,fn) ->
	    Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv)))
	  d }
| x0 = storage t = ctype d = comma_list_d_ident_ pv = TPtVirg
    {let s =
  let x = x0 in
  ( Some x )
in
 List.map
	  (function (id,fn) ->
	    Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv)))
	  d }
| f = funproto
    { [f] }
| t = ctype d = d_ident q = TEq e = initialize pv = TPtVirg
    {let s =
  ( None )
in
 let (id,fn) = d in
      [Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv))] }
| x0 = storage t = ctype d = d_ident q = TEq e = initialize pv = TPtVirg
    {let s =
  let x = x0 in
  ( Some x )
in
 let (id,fn) = d in
      [Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv))] }
| i = pure_ident d = comma_list_d_ident_ pv = TPtVirg
    {let cv =
  ( None )
in
let s =
  ( None )
in
 List.map
	  (function (id,fn) ->
	    let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	    Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)))
	  d }
| x0 = const_vol i = pure_ident d = comma_list_d_ident_ pv = TPtVirg
    {let cv =
  let x = x0 in
  ( Some x )
in
let s =
  ( None )
in
 List.map
	  (function (id,fn) ->
	    let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	    Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)))
	  d }
| x0 = storage i = pure_ident d = comma_list_d_ident_ pv = TPtVirg
    {let cv =
  ( None )
in
let s =
  let x = x0 in
  ( Some x )
in
 List.map
	  (function (id,fn) ->
	    let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	    Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)))
	  d }
| x0 = storage x1 = const_vol i = pure_ident d = comma_list_d_ident_ pv = TPtVirg
    {let cv =
  let x = x1 in
  ( Some x )
in
let s =
  let x = x0 in
  ( Some x )
in
 List.map
	  (function (id,fn) ->
	    let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	    Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)))
	  d }
| i = pure_ident d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =
  ( None )
in
let s =
  ( None )
in
 let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      [Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv))] }
| x0 = const_vol i = pure_ident d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =
  let x = x0 in
  ( Some x )
in
let s =
  ( None )
in
 let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      [Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv))] }
| x0 = storage i = pure_ident d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =
  ( None )
in
let s =
  let x = x0 in
  ( Some x )
in
 let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      [Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv))] }
| x0 = storage x1 = const_vol i = pure_ident d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =
  let x = x1 in
  ( Some x )
in
let s =
  let x = x0 in
  ( Some x )
in
 let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      [Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv))] }
| t = fn_ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar pv = TPtVirg
    {let s =
  ( None )
in
 let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
        [Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv))] }
| x0 = storage t = fn_ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar pv = TPtVirg
    {let s =
  let x = x0 in
  ( Some x )
in
 let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
        [Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv))] }
| TDeclarerId TOPar eexpr_list_option TCPar TPtVirg
    { [Ast0.wrap(Ast0.MacroDecl(P.id2mcode $1,P.clt2mcode "(" $2,$3,
				  P.clt2mcode ")" $4,P.clt2mcode ";" $5))] }
| t = fn_ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar q = TEq e = initialize pv = TPtVirg
    {let s =
  ( None )
in
 let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
      [Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv))] }
| x0 = storage t = fn_ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar q = TEq e = initialize pv = TPtVirg
    {let s =
  let x = x0 in
  ( Some x )
in
 let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
      [Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv))] }

d_ident:
| ident list_array_dec_
    { ($1,
	 function t ->
	   List.fold_right
	     (function (l,i,r) ->
	       function rest ->
		 Ast0.wrap
		   (Ast0.Array(rest,P.clt2mcode "[" l,i,P.clt2mcode "]" r)))
	     $2 t) }

array_dec:
| l = TOCro i = option_eexpr_ r = TCCro
    { (l,i,r) }

initialize:
| eexpr
    { Ast0.wrap(Ast0.InitExpr($1)) }
| TOBrace initialize_list TCBrace
    { Ast0.wrap(Ast0.InitList(P.clt2mcode "{" $1,$2,P.clt2mcode "}" $3)) }
| TOBrace TCBrace
    { Ast0.wrap
	  (Ast0.InitList(P.clt2mcode "{" $1,Ast0.wrap(Ast0.DOTS []),
			 P.clt2mcode "}" $2)) }

initialize2:
| arith_expr_eexpr_invalid_
    { Ast0.wrap(Ast0.InitExpr($1)) }
| TOBrace initialize_list TCBrace
    { Ast0.wrap(Ast0.InitList(P.clt2mcode "{" $1,$2,P.clt2mcode "}" $3)) }
| TOBrace TCBrace
    { Ast0.wrap
	(Ast0.InitList(P.clt2mcode "{" $1,Ast0.wrap(Ast0.DOTS []),
		       P.clt2mcode "}" $2)) }
| TDot ident TEq initialize2
    { Ast0.wrap(Ast0.InitGccDotName(P.clt2mcode "." $1,$2,P.clt2mcode "=" $3,$4)) }
| ident TDotDot initialize2
    { Ast0.wrap(Ast0.InitGccName($1,P.clt2mcode ":" $2,$3)) }
| TOCro eexpr TCCro TEq initialize2
    { Ast0.wrap(Ast0.InitGccIndex(P.clt2mcode "[" $1,$2,P.clt2mcode "]" $3,
				  P.clt2mcode "=" $4,$5)) }
| TOCro eexpr TEllipsis eexpr TCCro TEq initialize2
    { Ast0.wrap(Ast0.InitGccRange(P.clt2mcode "[" $1,$2,P.clt2mcode "..." $3,
				  $4,P.clt2mcode "]" $5,P.clt2mcode "=" $6,$7)) }

initialize_list:
| initialize_list_start
    { Ast0.wrap(Ast0.DOTS($1)) }

initialize_list_start:
| initialize2 TComma
    { [$1;Ast0.wrap(Ast0.IComma(P.clt2mcode "," $2))] }
| initialize2 TComma initialize_list_start
    { $1::Ast0.wrap(Ast0.IComma(P.clt2mcode "," $2))::$3 }
| d = edots_when_TEllipsis_initialize_ r = comma_initializers_edots_when_TEllipsis_initialize__
    { (P.mkidots "..." d)::
      (List.concat(List.map (function x -> x (P.mkidots "...")) r)) }

comma_initializers_edots_when_TEllipsis_initialize__:
| 
    { [] }
| d = edots_when_TEllipsis_initialize_ r = comma_initializers2_edots_when_TEllipsis_initialize__
    { (function dot_builder -> [dot_builder d])::r }
| i = initialize2 c = TComma r = comma_initializers_edots_when_TEllipsis_initialize__
    { (function dot_builder -> [i; Ast0.wrap(Ast0.IComma(P.clt2mcode "," c))])::
      r }

comma_initializers2_edots_when_TEllipsis_initialize__:
| 
    { [] }
| i = initialize2 c = TComma r = comma_initializers_edots_when_TEllipsis_initialize__
    { (function dot_builder -> [i; Ast0.wrap(Ast0.IComma(P.clt2mcode "," c))])::
      r }

decl_statement:
| TMetaStmList
    { let (nm,pure,clt) = $1 in
      [Ast0.wrap(Ast0.MetaStmt(P.clt2mcode nm clt,pure))] }
| decl_var
    { List.map
	  (function x ->
	    Ast0.wrap
	      (Ast0.Decl((Ast0.default_info(),Ast0.context_befaft()),x)))
	  $1 }
| statement
    { [$1] }
| TOPar0 pre_post_decl_statement_and_expression_opt_mid TCPar0
    { let (first,rest) = $2 in
        let (mids,code) = List.split rest in
	let code = first :: code in
	if List.for_all
	    (function x ->
	      match Ast0.unwrap x with Ast0.DOTS([]) -> true | _ -> false)
	    code
      then []
      else [Ast0.wrap(Ast0.Disj(P.clt2mcode "(" $1,
				code, mids,
				P.clt2mcode ")" $3))] }

expr:
| basic_expr_expr_invalid_
    { $1 }

eexpr:
| basic_expr_eexpr_dot_expressions_
    { $1 }

dexpr:
| basic_expr_eexpr_nest_expressions_
    { $1 }

invalid:
| TInvalid
    { raise (Semantic_cocci.Semantic "not matchable") }

dot_expressions:
| TEllipsis
    { Ast0.wrap(Ast0.Edots(P.clt2mcode "..." $1,None)) }
| nest_expressions
    { $1 }

basic_expr_expr_invalid_:
| assign_expr_expr_invalid_
    { $1 }

basic_expr_eexpr_nest_expressions_:
| assign_expr_eexpr_nest_expressions_
    { $1 }

basic_expr_eexpr_dot_expressions_:
| assign_expr_eexpr_dot_expressions_
    { $1 }

assign_expr_expr_invalid_:
| cond_expr_expr_invalid_
    { $1 }
| unary_expr_expr_invalid_ TAssign assign_expr_expr_invalid_
    { let (op,clt) = $2 in
      Ast0.wrap(Ast0.Assignment($1,P.clt2mcode op clt,$3)) }
| unary_expr_expr_invalid_ TEq assign_expr_expr_invalid_
    { Ast0.wrap
	  (Ast0.Assignment
	     ($1,P.clt2mcode Ast.SimpleAssign $2,$3)) }

assign_expr_eexpr_nest_expressions_:
| cond_expr_eexpr_nest_expressions_
    { $1 }
| unary_expr_eexpr_nest_expressions_ TAssign assign_expr_eexpr_nest_expressions_
    { let (op,clt) = $2 in
      Ast0.wrap(Ast0.Assignment($1,P.clt2mcode op clt,$3)) }
| unary_expr_eexpr_nest_expressions_ TEq assign_expr_eexpr_nest_expressions_
    { Ast0.wrap
	  (Ast0.Assignment
	     ($1,P.clt2mcode Ast.SimpleAssign $2,$3)) }

assign_expr_eexpr_dot_expressions_:
| cond_expr_eexpr_dot_expressions_
    { $1 }
| unary_expr_eexpr_dot_expressions_ TAssign assign_expr_eexpr_dot_expressions_
    { let (op,clt) = $2 in
      Ast0.wrap(Ast0.Assignment($1,P.clt2mcode op clt,$3)) }
| unary_expr_eexpr_dot_expressions_ TEq assign_expr_eexpr_dot_expressions_
    { Ast0.wrap
	  (Ast0.Assignment
	     ($1,P.clt2mcode Ast.SimpleAssign $2,$3)) }

cond_expr_expr_invalid_:
| arith_expr_expr_invalid_
    { $1 }
| l = arith_expr_expr_invalid_ w = TWhy t = option_eexpr_ dd = TDotDot r = cond_expr_expr_invalid_
    { Ast0.wrap(Ast0.CondExpr (l, P.clt2mcode "?" w, t,
				 P.clt2mcode ":" dd, r)) }

cond_expr_eexpr_nest_expressions_:
| arith_expr_eexpr_nest_expressions_
    { $1 }
| l = arith_expr_eexpr_nest_expressions_ w = TWhy t = option_eexpr_ dd = TDotDot r = cond_expr_eexpr_nest_expressions_
    { Ast0.wrap(Ast0.CondExpr (l, P.clt2mcode "?" w, t,
				 P.clt2mcode ":" dd, r)) }

cond_expr_eexpr_dot_expressions_:
| arith_expr_eexpr_dot_expressions_
    { $1 }
| l = arith_expr_eexpr_dot_expressions_ w = TWhy t = option_eexpr_ dd = TDotDot r = cond_expr_eexpr_dot_expressions_
    { Ast0.wrap(Ast0.CondExpr (l, P.clt2mcode "?" w, t,
				 P.clt2mcode ":" dd, r)) }

arith_expr_expr_invalid_:
| cast_expr_expr_invalid_
    { $1 }
| arith_expr_expr_invalid_ TMul arith_expr_expr_invalid_
    { P.arith_op Ast.Mul $1 $2 $3 }
| arith_expr_expr_invalid_ TDiv arith_expr_expr_invalid_
    { P.arith_op Ast.Div $1 $2 $3 }
| arith_expr_expr_invalid_ TMod arith_expr_expr_invalid_
    { P.arith_op Ast.Mod $1 $2 $3 }
| arith_expr_expr_invalid_ TPlus arith_expr_expr_invalid_
    { P.arith_op Ast.Plus $1 $2 $3 }
| arith_expr_expr_invalid_ TMinus arith_expr_expr_invalid_
    { P.arith_op Ast.Minus $1 $2 $3 }
| arith_expr_expr_invalid_ TShl arith_expr_expr_invalid_
    { P.arith_op Ast.DecLeft $1 $2 $3 }
| arith_expr_expr_invalid_ TShr arith_expr_expr_invalid_
    { P.arith_op Ast.DecRight $1 $2 $3}
| arith_expr_expr_invalid_ TInf arith_expr_expr_invalid_
    { P.logic_op Ast.Inf $1 $2 $3 }
| arith_expr_expr_invalid_ TSup arith_expr_expr_invalid_
    { P.logic_op Ast.Sup $1 $2 $3 }
| arith_expr_expr_invalid_ TInfEq arith_expr_expr_invalid_
    { P.logic_op Ast.InfEq $1 $2 $3 }
| arith_expr_expr_invalid_ TSupEq arith_expr_expr_invalid_
    { P.logic_op Ast.SupEq $1 $2 $3 }
| arith_expr_expr_invalid_ TEqEq arith_expr_expr_invalid_
    { P.logic_op Ast.Eq $1 $2 $3 }
| arith_expr_expr_invalid_ TNotEq arith_expr_expr_invalid_
    { P.logic_op Ast.NotEq $1 $2 $3 }
| arith_expr_expr_invalid_ TAnd arith_expr_expr_invalid_
    { P.arith_op Ast.And $1 $2 $3 }
| arith_expr_expr_invalid_ TOr arith_expr_expr_invalid_
    { P.arith_op Ast.Or $1 $2 $3 }
| arith_expr_expr_invalid_ TXor arith_expr_expr_invalid_
    { P.arith_op Ast.Xor $1 $2 $3 }
| arith_expr_expr_invalid_ TAndLog arith_expr_expr_invalid_
    { P.logic_op Ast.AndLog $1 $2 $3 }
| arith_expr_expr_invalid_ TOrLog arith_expr_expr_invalid_
    { P.logic_op Ast.OrLog $1 $2 $3 }

arith_expr_eexpr_nest_expressions_:
| cast_expr_eexpr_nest_expressions_
    { $1 }
| arith_expr_eexpr_nest_expressions_ TMul arith_expr_eexpr_nest_expressions_
    { P.arith_op Ast.Mul $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TDiv arith_expr_eexpr_nest_expressions_
    { P.arith_op Ast.Div $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TMod arith_expr_eexpr_nest_expressions_
    { P.arith_op Ast.Mod $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TPlus arith_expr_eexpr_nest_expressions_
    { P.arith_op Ast.Plus $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TMinus arith_expr_eexpr_nest_expressions_
    { P.arith_op Ast.Minus $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TShl arith_expr_eexpr_nest_expressions_
    { P.arith_op Ast.DecLeft $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TShr arith_expr_eexpr_nest_expressions_
    { P.arith_op Ast.DecRight $1 $2 $3}
| arith_expr_eexpr_nest_expressions_ TInf arith_expr_eexpr_nest_expressions_
    { P.logic_op Ast.Inf $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TSup arith_expr_eexpr_nest_expressions_
    { P.logic_op Ast.Sup $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TInfEq arith_expr_eexpr_nest_expressions_
    { P.logic_op Ast.InfEq $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TSupEq arith_expr_eexpr_nest_expressions_
    { P.logic_op Ast.SupEq $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TEqEq arith_expr_eexpr_nest_expressions_
    { P.logic_op Ast.Eq $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TNotEq arith_expr_eexpr_nest_expressions_
    { P.logic_op Ast.NotEq $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TAnd arith_expr_eexpr_nest_expressions_
    { P.arith_op Ast.And $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TOr arith_expr_eexpr_nest_expressions_
    { P.arith_op Ast.Or $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TXor arith_expr_eexpr_nest_expressions_
    { P.arith_op Ast.Xor $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TAndLog arith_expr_eexpr_nest_expressions_
    { P.logic_op Ast.AndLog $1 $2 $3 }
| arith_expr_eexpr_nest_expressions_ TOrLog arith_expr_eexpr_nest_expressions_
    { P.logic_op Ast.OrLog $1 $2 $3 }

arith_expr_eexpr_invalid_:
| cast_expr_eexpr_invalid_
    { $1 }
| arith_expr_eexpr_invalid_ TMul arith_expr_eexpr_invalid_
    { P.arith_op Ast.Mul $1 $2 $3 }
| arith_expr_eexpr_invalid_ TDiv arith_expr_eexpr_invalid_
    { P.arith_op Ast.Div $1 $2 $3 }
| arith_expr_eexpr_invalid_ TMod arith_expr_eexpr_invalid_
    { P.arith_op Ast.Mod $1 $2 $3 }
| arith_expr_eexpr_invalid_ TPlus arith_expr_eexpr_invalid_
    { P.arith_op Ast.Plus $1 $2 $3 }
| arith_expr_eexpr_invalid_ TMinus arith_expr_eexpr_invalid_
    { P.arith_op Ast.Minus $1 $2 $3 }
| arith_expr_eexpr_invalid_ TShl arith_expr_eexpr_invalid_
    { P.arith_op Ast.DecLeft $1 $2 $3 }
| arith_expr_eexpr_invalid_ TShr arith_expr_eexpr_invalid_
    { P.arith_op Ast.DecRight $1 $2 $3}
| arith_expr_eexpr_invalid_ TInf arith_expr_eexpr_invalid_
    { P.logic_op Ast.Inf $1 $2 $3 }
| arith_expr_eexpr_invalid_ TSup arith_expr_eexpr_invalid_
    { P.logic_op Ast.Sup $1 $2 $3 }
| arith_expr_eexpr_invalid_ TInfEq arith_expr_eexpr_invalid_
    { P.logic_op Ast.InfEq $1 $2 $3 }
| arith_expr_eexpr_invalid_ TSupEq arith_expr_eexpr_invalid_
    { P.logic_op Ast.SupEq $1 $2 $3 }
| arith_expr_eexpr_invalid_ TEqEq arith_expr_eexpr_invalid_
    { P.logic_op Ast.Eq $1 $2 $3 }
| arith_expr_eexpr_invalid_ TNotEq arith_expr_eexpr_invalid_
    { P.logic_op Ast.NotEq $1 $2 $3 }
| arith_expr_eexpr_invalid_ TAnd arith_expr_eexpr_invalid_
    { P.arith_op Ast.And $1 $2 $3 }
| arith_expr_eexpr_invalid_ TOr arith_expr_eexpr_invalid_
    { P.arith_op Ast.Or $1 $2 $3 }
| arith_expr_eexpr_invalid_ TXor arith_expr_eexpr_invalid_
    { P.arith_op Ast.Xor $1 $2 $3 }
| arith_expr_eexpr_invalid_ TAndLog arith_expr_eexpr_invalid_
    { P.logic_op Ast.AndLog $1 $2 $3 }
| arith_expr_eexpr_invalid_ TOrLog arith_expr_eexpr_invalid_
    { P.logic_op Ast.OrLog $1 $2 $3 }

arith_expr_eexpr_dot_expressions_:
| cast_expr_eexpr_dot_expressions_
    { $1 }
| arith_expr_eexpr_dot_expressions_ TMul arith_expr_eexpr_dot_expressions_
    { P.arith_op Ast.Mul $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TDiv arith_expr_eexpr_dot_expressions_
    { P.arith_op Ast.Div $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TMod arith_expr_eexpr_dot_expressions_
    { P.arith_op Ast.Mod $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TPlus arith_expr_eexpr_dot_expressions_
    { P.arith_op Ast.Plus $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TMinus arith_expr_eexpr_dot_expressions_
    { P.arith_op Ast.Minus $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TShl arith_expr_eexpr_dot_expressions_
    { P.arith_op Ast.DecLeft $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TShr arith_expr_eexpr_dot_expressions_
    { P.arith_op Ast.DecRight $1 $2 $3}
| arith_expr_eexpr_dot_expressions_ TInf arith_expr_eexpr_dot_expressions_
    { P.logic_op Ast.Inf $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TSup arith_expr_eexpr_dot_expressions_
    { P.logic_op Ast.Sup $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TInfEq arith_expr_eexpr_dot_expressions_
    { P.logic_op Ast.InfEq $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TSupEq arith_expr_eexpr_dot_expressions_
    { P.logic_op Ast.SupEq $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TEqEq arith_expr_eexpr_dot_expressions_
    { P.logic_op Ast.Eq $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TNotEq arith_expr_eexpr_dot_expressions_
    { P.logic_op Ast.NotEq $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TAnd arith_expr_eexpr_dot_expressions_
    { P.arith_op Ast.And $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TOr arith_expr_eexpr_dot_expressions_
    { P.arith_op Ast.Or $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TXor arith_expr_eexpr_dot_expressions_
    { P.arith_op Ast.Xor $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TAndLog arith_expr_eexpr_dot_expressions_
    { P.logic_op Ast.AndLog $1 $2 $3 }
| arith_expr_eexpr_dot_expressions_ TOrLog arith_expr_eexpr_dot_expressions_
    { P.logic_op Ast.OrLog $1 $2 $3 }

cast_expr_expr_invalid_:
| unary_expr_expr_invalid_
    { $1 }
| lp = TOPar t = ctype rp = TCPar e = cast_expr_expr_invalid_
    { Ast0.wrap(Ast0.Cast (P.clt2mcode "(" lp, t,
			     P.clt2mcode ")" rp, e)) }

cast_expr_eexpr_nest_expressions_:
| unary_expr_eexpr_nest_expressions_
    { $1 }
| lp = TOPar t = ctype rp = TCPar e = cast_expr_eexpr_nest_expressions_
    { Ast0.wrap(Ast0.Cast (P.clt2mcode "(" lp, t,
			     P.clt2mcode ")" rp, e)) }

cast_expr_eexpr_invalid_:
| unary_expr_eexpr_invalid_
    { $1 }
| lp = TOPar t = ctype rp = TCPar e = cast_expr_eexpr_invalid_
    { Ast0.wrap(Ast0.Cast (P.clt2mcode "(" lp, t,
			     P.clt2mcode ")" rp, e)) }

cast_expr_eexpr_dot_expressions_:
| unary_expr_eexpr_dot_expressions_
    { $1 }
| lp = TOPar t = ctype rp = TCPar e = cast_expr_eexpr_dot_expressions_
    { Ast0.wrap(Ast0.Cast (P.clt2mcode "(" lp, t,
			     P.clt2mcode ")" rp, e)) }

unary_expr_expr_invalid_:
| postfix_expr_expr_invalid_
    { $1 }
| TInc unary_expr_expr_invalid_
    { Ast0.wrap(Ast0.Infix ($2, P.clt2mcode Ast.Inc $1)) }
| TDec unary_expr_expr_invalid_
    { Ast0.wrap(Ast0.Infix ($2, P.clt2mcode Ast.Dec $1)) }
| unary_op unary_expr_expr_invalid_
    { let mcode = $1 in Ast0.wrap(Ast0.Unary($2, mcode)) }
| TSizeof unary_expr_expr_invalid_
    { Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" $1, $2)) }
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    { Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,
                                   t,
                                   P.clt2mcode ")" rp)) }

unary_expr_eexpr_nest_expressions_:
| postfix_expr_eexpr_nest_expressions_
    { $1 }
| TInc unary_expr_eexpr_nest_expressions_
    { Ast0.wrap(Ast0.Infix ($2, P.clt2mcode Ast.Inc $1)) }
| TDec unary_expr_eexpr_nest_expressions_
    { Ast0.wrap(Ast0.Infix ($2, P.clt2mcode Ast.Dec $1)) }
| unary_op unary_expr_eexpr_nest_expressions_
    { let mcode = $1 in Ast0.wrap(Ast0.Unary($2, mcode)) }
| TSizeof unary_expr_eexpr_nest_expressions_
    { Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" $1, $2)) }
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    { Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,
                                   t,
                                   P.clt2mcode ")" rp)) }

unary_expr_eexpr_invalid_:
| postfix_expr_eexpr_invalid_
    { $1 }
| TInc unary_expr_eexpr_invalid_
    { Ast0.wrap(Ast0.Infix ($2, P.clt2mcode Ast.Inc $1)) }
| TDec unary_expr_eexpr_invalid_
    { Ast0.wrap(Ast0.Infix ($2, P.clt2mcode Ast.Dec $1)) }
| unary_op unary_expr_eexpr_invalid_
    { let mcode = $1 in Ast0.wrap(Ast0.Unary($2, mcode)) }
| TSizeof unary_expr_eexpr_invalid_
    { Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" $1, $2)) }
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    { Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,
                                   t,
                                   P.clt2mcode ")" rp)) }

unary_expr_eexpr_dot_expressions_:
| postfix_expr_eexpr_dot_expressions_
    { $1 }
| TInc unary_expr_eexpr_dot_expressions_
    { Ast0.wrap(Ast0.Infix ($2, P.clt2mcode Ast.Inc $1)) }
| TDec unary_expr_eexpr_dot_expressions_
    { Ast0.wrap(Ast0.Infix ($2, P.clt2mcode Ast.Dec $1)) }
| unary_op unary_expr_eexpr_dot_expressions_
    { let mcode = $1 in Ast0.wrap(Ast0.Unary($2, mcode)) }
| TSizeof unary_expr_eexpr_dot_expressions_
    { Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" $1, $2)) }
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    { Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,
                                   t,
                                   P.clt2mcode ")" rp)) }

unary_op:
| TAnd
    { P.clt2mcode Ast.GetRef $1 }
| TMul
    { P.clt2mcode Ast.DeRef $1 }
| TPlus
    { P.clt2mcode Ast.UnPlus $1 }
| TMinus
    { P.clt2mcode Ast.UnMinus $1 }
| TTilde
    { P.clt2mcode Ast.Tilde $1 }
| TBang
    { P.clt2mcode Ast.Not $1 }

expr_dots_TEllipsis_:
| r = no_dot_start_end_dexpr_edots_when_TEllipsis_eexpr__
    { r }

func_ident:
| pure_ident
    { Ast0.wrap(Ast0.Id(P.id2mcode $1)) }
| TMetaId
    { let (nm,pure,clt) = $1 in
           Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,pure)) }
| TMetaFunc
    { let (nm,pure,clt) = $1 in
           Ast0.wrap(Ast0.MetaFunc(P.clt2mcode nm clt,pure)) }
| TMetaLocalFunc
    { let (nm,pure,clt) = $1 in
           Ast0.wrap(Ast0.MetaLocalFunc(P.clt2mcode nm clt,pure)) }

ident:
| pure_ident
    { Ast0.wrap(Ast0.Id(P.id2mcode $1)) }
| TMetaId
    { let (nm,pure,clt) = $1 in
           Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,pure)) }

decl_list_name_opt_decl_:
| decl_list_start_name_opt_decl_
    {let circle x =
       match Ast0.unwrap x with Ast0.Pcircles(_) -> true | _ -> false in
     if List.exists circle $1
     then Ast0.wrap(Ast0.CIRCLES($1))
     else Ast0.wrap(Ast0.DOTS($1)) }

decl_list_decl_:
| decl_list_start_decl_
    {let circle x =
       match Ast0.unwrap x with Ast0.Pcircles(_) -> true | _ -> false in
     if List.exists circle $1
     then Ast0.wrap(Ast0.CIRCLES($1))
     else Ast0.wrap(Ast0.DOTS($1)) }

decl_list_start_name_opt_decl_:
| one_dec_name_opt_decl_
    { [$1] }
| one_dec_name_opt_decl_ TComma decl_list_start_name_opt_decl_
    { $1::Ast0.wrap(Ast0.PComma(P.clt2mcode "," $2))::$3 }
| TEllipsis list_comma_decls_TEllipsis_name_opt_decl__
    { Ast0.wrap(Ast0.Pdots(P.clt2mcode "..." $1))::
      (List.concat(List.map (function x -> x (P.mkpdots "...")) $2)) }

decl_list_start_decl_:
| one_dec_decl_
    { [$1] }
| one_dec_decl_ TComma decl_list_start_decl_
    { $1::Ast0.wrap(Ast0.PComma(P.clt2mcode "," $2))::$3 }
| TEllipsis list_comma_decls_TEllipsis_decl__
    { Ast0.wrap(Ast0.Pdots(P.clt2mcode "..." $1))::
      (List.concat(List.map (function x -> x (P.mkpdots "...")) $2)) }

comma_decls_TEllipsis_name_opt_decl_:
| TComma TEllipsis
    { function dot_builder ->
      [Ast0.wrap(Ast0.PComma(P.clt2mcode "," $1));
	dot_builder $2] }
| TComma one_dec_name_opt_decl_
    { function dot_builder ->
      [Ast0.wrap(Ast0.PComma(P.clt2mcode "," $1)); $2] }

comma_decls_TEllipsis_decl_:
| TComma TEllipsis
    { function dot_builder ->
      [Ast0.wrap(Ast0.PComma(P.clt2mcode "," $1));
	dot_builder $2] }
| TComma one_dec_decl_
    { function dot_builder ->
      [Ast0.wrap(Ast0.PComma(P.clt2mcode "," $1)); $2] }

exp_decl_statement_list:
| TNothing
    { [] }
| expr
    { [Ast0.wrap(Ast0.Exp($1))] }
| expr TOEllipsis b = statement_dots_TEllipsis_ TCEllipsis exp_decl_statement_list
    { (Ast0.wrap(Ast0.Exp($1)))::
      (Ast0.wrap(Ast0.Nest(P.clt2mcode "<..." $2,
			  Ast0.wrap(Ast0.DOTS(b (P.mkdots "..."))),
			  P.clt2mcode "...>" $4, None)))::
      $5 }
| expr TOEllipsis b = statement_dots_TEllipsis_ TCEllipsis
    { [(Ast0.wrap(Ast0.Exp($1)));
	(Ast0.wrap(Ast0.Nest(P.clt2mcode "<..." $2,
			     Ast0.wrap(Ast0.DOTS(b (P.mkdots "..."))),
			     P.clt2mcode "...>" $4, None)))] }
| pure_decl_statement_list
    { $1 }

fun_exp_decl_statement_list:
| TNothing
    { [] }
| t = ctype
    { [Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Ty(t))))] }
| lp = TOPar0 t = midzero_list_ctype_ rp = TCPar0
    { let (mids,code) = t in
    let s =
      Ast0.wrap(Ast0.DisjType(P.clt2mcode "(" lp,code,mids, P.clt2mcode ")" rp)) in
    [Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Ty(s))))]}
| expr
    { [Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Exp($1))))] }
| expr TOEllipsis b = statement_dots_TEllipsis_ TCEllipsis fun_exp_decl_statement_list
    { (Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Exp($1)))))::
      (Ast0.wrap
	 (Ast0.OTHER
	    (Ast0.wrap
	       (Ast0.Nest(P.clt2mcode "<..." $2,
			  Ast0.wrap(Ast0.DOTS(b (P.mkdots "..."))),
			  P.clt2mcode "...>" $4, None)))))::
      $5 }
| expr TOEllipsis b = statement_dots_TEllipsis_ TCEllipsis
    { [(Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Exp($1)))));
      (Ast0.wrap
	 (Ast0.OTHER
	    (Ast0.wrap
	       (Ast0.Nest(P.clt2mcode "<..." $2,
			  Ast0.wrap(Ast0.DOTS(b (P.mkdots "..."))),
			  P.clt2mcode "...>" $4, None)))))] }
| f = nonempty_list_fun_decl_statement_
    { List.concat f }

fun_decl_statement:
| d = decl_statement
    { List.map (function x -> Ast0.wrap(Ast0.OTHER x)) d }
| f = fundecl
    { [Ast0.wrap(Ast0.DECL(f))] }

error_words:
| TError TWords TEq TOCro cl = comma_list_dexpr_ TCCro
    { [Ast0.wrap(Ast0.ERRORWORDS(cl))] }

pre_post_decl_statement_and_expression_opt_mid:
| pre_post_decl_statement_and_expression
    { ($1,[]) }
| 
    { (Ast0.wrap(Ast0.DOTS([])),[]) }
| pre_post_decl_statement_and_expression TMid0 pre_post_decl_statement_and_expression_opt_mid
    { let (first,rest) = $3 in
        ($1,(P.clt2mcode "|" $2,first)::rest) }
| TMid0 pre_post_decl_statement_and_expression_opt_mid
    { let (first,rest) = $2 in
        (Ast0.wrap(Ast0.DOTS([])),
	 (P.clt2mcode "|" $1,first)::rest) }

eexpr_list:
| eexpr_list_start
    {let circle x =
       match Ast0.unwrap x with Ast0.Ecircles(_) -> true | _ -> false in
     let star x =
       match Ast0.unwrap x with Ast0.Estars(_) -> true | _ -> false in
     if List.exists circle $1
     then Ast0.wrap(Ast0.CIRCLES($1))
     else
       if List.exists star $1
       then Ast0.wrap(Ast0.STARS($1))
       else Ast0.wrap(Ast0.DOTS($1)) }

aexpr:
| dexpr
    { $1 }
| TMetaExpList
    { let (nm,pure,clt) = $1 in
      Ast0.wrap(Ast0.MetaExprList(P.clt2mcode nm clt,pure)) }
| generic_ctype
    { Ast0.wrap(Ast0.TypeExp($1)) }

eexpr_list_start:
| aexpr
    { [$1] }
| aexpr TComma eexpr_list_start
    { $1::Ast0.wrap(Ast0.EComma(P.clt2mcode "," $2))::$3 }
| d = edots_when_TEllipsis_eexpr_ r = list_comma_args_edots_when_TEllipsis_eexpr___
    { (P.mkedots "..." d)::
	(List.concat (List.map (function x -> x (P.mkedots "...")) r)) }

comma_args_edots_when_TEllipsis_eexpr__:
| c = TComma d = edots_when_TEllipsis_eexpr_
    { function dot_builder ->
      [Ast0.wrap(Ast0.EComma(P.clt2mcode "," c)); dot_builder d] }
| TComma aexpr
    { function dot_builder ->
      [Ast0.wrap(Ast0.EComma(P.clt2mcode "," $1)); $2] }

eexpr_list_option:
| eexpr_list
    { $1 }
| 
    { Ast0.wrap(Ast0.DOTS([])) }

comma_list_pure_ident_or_meta_ident_:
| separated_nonempty_list_TComma_pure_ident_or_meta_ident_
    { $1 }

comma_list_dexpr_:
| separated_nonempty_list_TComma_dexpr_
    { $1 }

comma_list_d_ident_:
| separated_nonempty_list_TComma_d_ident_
    { $1 }

comma_list_ctype_:
| separated_nonempty_list_TComma_ctype_
    { $1 }

opt_dot_start_end_pattern_fun_exp_decl_statement_list_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__fun_exp_decl_statement_list_opt_dot_end_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list__:
| g = fun_exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_
    { function dot_builder -> [g; (dot_builder d)] }
| g = fun_exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ c = opt_dot_end_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    { function dot_builder -> g :: (dot_builder d) :: (c dot_builder) }
| d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ c = opt_dot_end_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    { function dot_builder -> (dot_builder d) :: (c dot_builder) }

opt_dot_start_end_pattern_exp_decl_statement_list_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__exp_decl_statement_list_opt_dot_end_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list__:
| g = exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_
    { function dot_builder -> [g; (dot_builder d)] }
| g = exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ c = opt_dot_end_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list_
    { function dot_builder -> g :: (dot_builder d) :: (c dot_builder) }
| d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ c = opt_dot_end_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list_
    { function dot_builder -> (dot_builder d) :: (c dot_builder) }

opt_dot_end_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_:
| g = fun_exp_decl_statement_list
    { function dot_builder -> [g] }
| g = fun_exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_
    { function dot_builder -> [g ; dot_builder d ] }
| g = fun_exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ r = opt_dot_end_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    { function dot_builder -> g :: (dot_builder d) :: (r dot_builder) }

opt_dot_end_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list_:
| g = exp_decl_statement_list
    { function dot_builder -> [g] }
| g = exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_
    { function dot_builder -> [g ; dot_builder d ] }
| g = exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ r = opt_dot_end_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list_
    { function dot_builder -> g :: (dot_builder d) :: (r dot_builder) }

no_dot_start_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_:
| 
    { function dot_builder -> [] }
| e = fun_exp_decl_statement_list
    { function dot_builder -> [e] }
| g = fun_exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ r = no_dot_start_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    { function dot_builder -> g::(dot_builder d)::(r dot_builder) }

no_dot_start_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_pure_decl_statement_list_:
| 
    { function dot_builder -> [] }
| e = pure_decl_statement_list
    { function dot_builder -> [e] }
| g = exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ r = no_dot_start_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_pure_decl_statement_list_
    { function dot_builder -> g::(dot_builder d)::(r dot_builder) }

edots_when_TEllipsis_struct_decl_:
| d = TEllipsis
    { (d,None) }
| d = TEllipsis TWhen TNotEq w = struct_decl TLineEnd
    { (d,Some w) }

edots_when_TEllipsis_initialize_:
| d = TEllipsis
    { (d,None) }
| d = TEllipsis TWhen TNotEq w = initialize TLineEnd
    { (d,Some w) }

edots_when_TEllipsis_eexpr_:
| d = TEllipsis
    { (d,None) }
| d = TEllipsis TWhen TNotEq w = eexpr TLineEnd
    { (d,Some w) }

dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_:
| d = TEllipsis w = list_whens_pre_post_decl_statement_or_expression_rule_elem_statement__
    { (d,w) }

whens_pre_post_decl_statement_or_expression_rule_elem_statement_:
| TWhen TNotEq w = pre_post_decl_statement_or_expression TLineEnd
    { Ast0.WhenNot w }
| TWhen TEq w = rule_elem_statement TLineEnd
    { Ast0.WhenAlways w }

no_dot_start_end_exp_decl_statement_list_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__:
| g = exp_decl_statement_list dg = list_pair_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__exp_decl_statement_list__
    { function dot_builder ->
      g :: (List.concat(List.map (function (d,g) -> [dot_builder d;g]) dg)) }

no_dot_start_end_dexpr_edots_when_TEllipsis_eexpr__:
| g = dexpr dg = list_pair_edots_when_TEllipsis_eexpr__dexpr__
    { function dot_builder ->
      g :: (List.concat(List.map (function (d,g) -> [dot_builder d;g]) dg)) }

xstatement_dots_TEllipsis_:
| b = statement_dots_TEllipsis_
    { Ast0.wrap(Ast0.DOTS(b (P.mkdots "..."))) }

never_used:
| TPragma
    { () }

loption_pure_decl_statement_list_:
| 
    { [] }
| x = pure_decl_statement_list
    { x }

loption_plus_function_decl_statement_or_expression_:
| 
    { [] }
| x = plus_function_decl_statement_or_expression
    { x }

iso_main:
| TIsoExpression e1 = dexpr el = list_iso_dexpr__ EOF
    { P.iso_adjust (function x -> Ast0.ExprTag x) e1 el }
| TIsoStatement s1 = single_statement sl = list_iso_single_statement__ EOF
    { P.iso_adjust (function x -> Ast0.StmtTag x) s1 sl }
| TIsoType t1 = ctype tl = list_iso_ctype__ EOF
    { P.iso_adjust (function x -> Ast0.TypeCTag x) t1 tl }
| TIsoTopLevel e1 = xstatement_dots_TEllipsis_ el = list_iso_xstatement_dots_TEllipsis___ EOF
    { P.iso_adjust (function x -> Ast0.DotsStmtTag x) e1 el }
| TIsoDeclaration d1 = decl_var dl = list_iso_decl_var__ EOF
    { let check_one = function
	[x] -> x
      | _ ->
	  raise
	    (Semantic_cocci.Semantic
	       "only one variable per declaration in an isomorphism rule") in
    let d1 = check_one d1 in
    let dl =
      List.map
	(function
	    Common.Left x -> Common.Left(check_one x)
	  | Common.Right x -> Common.Right(check_one x))
	dl in
    P.iso_adjust (function x -> Ast0.DeclTag x) d1 dl }

iso_xstatement_dots_TEllipsis__:
| TIso t = xstatement_dots_TEllipsis_
    { Common.Left t }
| TRightIso t = xstatement_dots_TEllipsis_
    { Common.Right t }

iso_single_statement_:
| TIso t = single_statement
    { Common.Left t }
| TRightIso t = single_statement
    { Common.Right t }

iso_dexpr_:
| TIso t = dexpr
    { Common.Left t }
| TRightIso t = dexpr
    { Common.Right t }

iso_decl_var_:
| TIso t = decl_var
    { Common.Left t }
| TRightIso t = decl_var
    { Common.Right t }

iso_ctype_:
| TIso t = ctype
    { Common.Left t }
| TRightIso t = ctype
    { Common.Right t }

%%



