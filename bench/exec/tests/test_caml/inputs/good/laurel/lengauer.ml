(* $Header: /home/yquem/cristal/fpottier/cvs/laurel/lengauer.ml,v 1.4 1999/12/22 13:37:30 fpottier Exp $ *)

(* This module provides an implementation of Lengauer and Tarjan's algorithm for finding dominators in a flow graph.

   The algorithm runs when the functor is applied. Its complexity is essentially $O(E)$, where $E$ is the number of
   edges in the graph $G$. *)

module Run (G : Graph.BasicPredStart) = struct

  (* Some of the arrays used by the algorithm have bounds $0\ldots n$, others $1\ldots n$. *)

  let np1 = G.n + 1

  (* Lengauer and Tarjan's original formulation of the algorithm assumes that vertices are integers. (Indeed, not
     only does this hypothesis allow vertex-indexed arrays, but it is heavily used in their implementation of [link]
     and [eval].) We do not wish to make such a hypothesis. So, during the algorithm's initial depth-first search, we
     translate nodes to integers, which we then feed to the algorithm. (We build two translation tables, [in_table]
     and [out_table].) As a side effect, the algorithm no longer needs to make a distinction between vertices and
     numbers; that is, the [vertex] array is the identity and disappears. *)

  let in_table =
    Array.create G.n None

  let out_table =
    Array.create np1 G.start (* for instance *)

  (* Initially, [semi.(w)] is the number of [w], i.e. [w] itself. After the semidominator of [w] is computed,
     [semi.(w)] is the number of the semidominator of [w]. *)

  let semi =
    Array.init np1 (fun w -> w)

  (* [parent.(w)] is the vertex which is the parent of vertex [w] in the spanning tree generated by the search. *)

  let parent =
    Array.create np1 0 (* for instance *)

  (* Step 1. Carry out a depth-first search of the problem graph. Number the vertices from 1 to $n$ as they are
     reached during the search. At the same time, initialize variables used in the succeeding steps. *)

  let counter =
    ref 0
      
  let rec walk father node =

    (* Initialize [parent], [in_table] and [out_table] with respect to node [node], which becomes vertex number
       [v]. *)

    let v = !counter + 1 in
    counter := v;

    Standard.do_option father (fun father ->
      parent.(v) <- father
    );

    in_table.(G.index node) <- Some v;
    out_table.(v) <- node;

    (* Continue the depth-first search. *)

    G.successors (fun successor ->
      if in_table.(G.index successor) = None then
	walk (Some v) successor
    ) node

  (* Perform the search, and make sure all nodes have been found. *)

  let _ =
    walk None G.start;
    assert (!counter = G.n)

  (* Define a function which conveniently converts a node into its vertex number. *)

  let in_table =
    Array.map (function
      |	Some v -> v
      |	None -> assert false (* Indices do not cover the range $0\ldots n-1$, as expected. *)
    ) in_table

  let number node =
    in_table.(G.index node)

  (* Define operations [eval] and [link] (sophisticated versions). *)

  let ancestor =
    Array.create np1 0

  let child =
    Array.create np1 0

  let size =
    Array.create np1 1

  let label =
    Array.init np1 (fun v -> v)

  let rec compress v =
    if ancestor.(ancestor.(v)) <> 0 then begin
      compress ancestor.(v);
      if semi.(label.(ancestor.(v))) < semi.(label.(v)) then
	label.(v) <- label.(ancestor.(v));
      ancestor.(v) <- ancestor.(ancestor.(v))
    end

  let eval v =
    if ancestor.(v) = 0 then
      label.(v)
    else begin
      compress v;
      if semi.(label.(ancestor.(v))) >= semi.(label.(v)) then
	label.(v)
      else
	label.(ancestor.(v))
    end

  let link v w =
    let s = ref w in
    while semi.(label.(w)) < semi.(label.(child.(!s))) do
      if size.(!s) + size.(child.(child.(!s))) >= 2 * size.(child.(!s))
      then begin
	ancestor.(child.(!s)) <- !s;
	child.(!s) <- child.(child.(!s))
      end
      else begin
	size.(child.(!s)) <- size.(!s);
	ancestor.(!s) <- child.(!s);
	s := ancestor.(!s)
      end
    done;
    label.(!s) <- label.(w);
    size.(v) <- size.(v) + size.(w);
    if size.(v) < 2 * size.(w) then begin
      let ts = !s in
      s := child.(v);
      child.(v) <- ts
    end;
    while !s <> 0 do
      ancestor.(!s) <- v;
      s := child.(!s)
    done

  (* After step 3, if the semidominator of [w] is its immediate dominator, then [dom.(w)] is the immediate dominator
     of [w]. Otherwise [dom.(w)] is a vertex [v] whose number is smaller than [w] amd whose immediate dominator is
     also [w]'s immediate dominator. After step 4, [dom.(w)] is the immediate dominator of [w]. *)

  let dom = 
    Array.create np1 0

  (* Step 2. Compute the semidominators of all vertices by applying Theorem 4. Carry out the computation vertex
     by vertex in decreasing order by number.

     Step 3. Implicitly define the immediate dominator of each vertex by applying Corollary 1.

     [bucket.(w)] is a set of vertices whose semidominator is [w]. *)

  let () = begin

    let bucket =
      Array.create np1 [] in

    for w = G.n downto 2 do

      (* Step 2. *)

      G.predecessors (fun node ->
	let semiu = semi.(eval (number node)) in
	if semiu < semi.(w) then
	  semi.(w) <- semiu
      ) out_table.(w);

      bucket.(semi.(w)) <- w :: bucket.(semi.(w));

      link parent.(w) w;

      (* Step 3. *)

      List.iter (fun v ->
	let u = eval v in
	dom.(v) <- if semi.(u) < semi.(v) then u else parent.(w)
      ) bucket.(parent.(w));

      bucket.(parent.(w)) <- []

    done;

    (* Step 4. *)

    for w = 2 to G.n do

      if dom.(w) <> semi.(w) then
	dom.(w) <- dom.(dom.(w))

    done

  end

  (* There only remains to make our results accessible to the outside. *)

  let dominator node =
    match dom.(number node) with
    | 0 ->
	None
    | w ->
	Some out_table.(w)

end

