Dans ce fichier, nous notons les points soulevés par les rapporteurs et
la façon dont nous avons réagi. Nos réponses sont marquées >>.

----------------------- REVIEW 1 ---------------------
PAPER: 66
TITLE: Validating LR(1) Parsers
AUTHORS: (anonymous)

However, the authors have not provided a link to their Coq sources
(neither in the paper, nor in their web pages): this is the only
reason why I only propose a "weak accept".

>> on va ajouter un lien vers les sources

In your conclusion on last page, you assert that it seems difficult to
define an aggressive interpreter instead of the defensive one exposed
in your paper, "even with the help of Sozeau's program extension".

Actually, I am convinced of (almost) the contrary. You could define an
aggressive version of your interpreter (without the dynamic checks
redundant with the proof) as a refinement of your defensive
interpreter under the precondition that your defensive interpreter do
not raise an internal error. And precisely, Sozeau's program extension
would be a great help to do so. In other words, you could use your
defensive interpreter as a specification of your aggressive one: the
former would appear both in the "precondition" and in the
"postcondition" of the latter. Hence, when defining the aggressive
interpreter, the safety invariant would simply be reformulated as "the
defensive interpreter does not raise an internal error given the
current stack, the current input state, etc".  As the structure of
your aggressive code would be not too far from the defensive version,
the proof obligations generated by Sozeau's program should not be not
too hard to prove.

In conclusion, the only drawback of the approach sketched above is
some redundancy between the defensive version and the aggressive one
(some code is written twice). But its main advantage is that in the
defensive version, you do not need to worry about "execution
efficiency" and you can focus on "proof simplicity", because you can
optimize "at will" your aggressive version.

In this approach, the "defensive interpreter" could also be replaced
by a more traditional Coq inductive definition (the semantics of the
automaton as a derivation tree). This would remove from the semantics
the need of internal errors (they would be replaced by inexistence of
some derivations) and the need of "fuel" (but it is still needed of
course in the aggressive interpreter). Hence, "safety" as expressed in
your "safety theorem" would be a consequence of "strong completeness"
(but unambiguity would require an additional proof that the semantics
is deterministic).

>> done: remercier et mentionner l'interprète agressif

--- MINOR REMARKS ---

- p.7. in the third case of the interpreter. 

  sentence "This can be thought of as reducing a special production
    $S' \rightarrow S$".

  I assume that you mean here the grammar is extended with a new axiom
  $S'$ replacing the old one, as it is done p.11 when introducing
  items.

>> oui; mais je n'ai rien changé au texte

- p.10. in the 2nd property verified by the "safety validator"

  sentence "If $k$ is greater that $n$, take $\Sigma_k$ to be the set
  of all states".

As I understand it, it would be clearer to say here that "$k \leq n$"
because I guess that it is implied by the condition
 "$\alpha$ is a suffix of $pastSymbols(\sigma)incoming(\sigma)$".

>> il a raison, du moins il aurait raison si pastStates et pastSymbols
>> avaient forcément la même longueur; je n'ai rien changé car c'est
>> comme ça actuellement

I have noted a single typo:

 - p. 18.  "In fact, we have proof ..." 

>> pas une typo

----------------------- REVIEW 2 ---------------------
PAPER: 66
TITLE: Validating LR(1) Parsers
AUTHORS: (anonymous)

Weak points:
Concerning the example section, the authors mention to apply a pre-parser,
which handles impure concepts like the typedef problem. In my interpretation,
this still imposes need for correctness proofs, especially as tinkering
with token-identities as sideeffects of parser-actions appears
risky when the parser works with a lookahead, i.e. a new type is introduced,
but has already read another token....

>> à discuter si vous voulez; je n'ai rien fait

----------------------- REVIEW 3 ---------------------
PAPER: 66
TITLE: Validating LR(1) Parsers
AUTHORS: (anonymous)

The reason why I am giving the paper only a weak accept is that while
most of the paper is clearly written, the two most crucial parts, which deal
with the validation of safety and completeness, are not (see the comments
below for pages 9 and 13). Based on past performance, I trust that in the
implementation, the INRIA team got things right, but in these two crucial
areas (unlike in the rest of the paper), they haven't proven it to readers.

The discussion on related work is good, though I am not in a position
to comment on its completeness. The discussion of future work is excellent.

Detailed comments:
p2 and later: In most compiler texts, SLR and LALR don't need a (1) suffix.

>> done

p2: You validate only the automaton, but claim correctness of its interpreter
as well. Where is the support of this claim?

>> j'ai bien relu l'intro, je ne ressens pas le besoin de modifier le texte.

p3: In the dragon book and elsewhere, what you calla "proto-phrase" is called
a "sentential form".

>> done

p4: Why do you assume the token stream is infinite?

>> we have already argued that there is no loss of generality; and it seems
>> simpler to do so. No change.

p5: I would reorder this list as 1423.

>> pourquoi pas, mais il me semble plus naturel d'expliquer "incoming symbol"
>> en dernier, et je préfère que l'ordre de la liste soit aussi l'ordre des
>> descriptions. No change.

p5: Where did footnotes 1 and 2 disappear to?

>> particularité du style LNCS. No change.

p7: Where would I find Remark 1?

>> supprimé une référence à cette remarque et précisé l'autre.

p8: You don't introduce the notation "s(sigma, v)".

>> fixed

p9: You don't give us any information about the MEANING of pastSymbols and
pastStates. For example, do pastSymbols and pastStates need to have the same
length, and a one-to-one correspondence? If yes, say so. If not, why not?

>> we do explain their meaning. The question of whether they have the same
>> length is somewhat irrelevant and is addressed in the future work section.

p10: WHY do you not need to demostrate this claim?

>> ce claim ("les informations sont toujours suffisantes pour montrer la
>> soundness") était mal écrit, je trouve, je l'ai supprimé. Maintenant,
>> peut-être faut-il expliquer pourquoi on ne prouve pas la complétude du
>> validateur?

p11: "eenvision" is ambiguous. Do you envision how it should work, or
just that you need it?

>> becomes irrelevant if we do strong completeness

p11: "further on" refers to which subsection?

>> fixed

p11: "recognize alpha2 and peek at a" -> "recognize alpha2 followed by a"

>> improved

p12: Point 1 would be easier to read if you replaces "a" with e.g. "t".
The "a" is hard to tell apart from the "alpha" that it descends from.

>> not sure what this means; anyway "a" is the standard letter, I don't
>> wan't to use "t"

p12: Point 4: why allow it to be undefined?

>> I don't know if we have enough space to point this out. Added a comment.

p12: Move point 7 first, next to the other text that talks about its contents.

>> done

p13: "a a"

>> fixed

p13: a path "into" the oracle tree -> a path "in" the oracle tree.
And what kind of path are you talking about? Is it a branch, allowed
to have at most one node on each level? Or can it meander around,
visiting the same node more than once? Even the description of the actions
that follows does not clear this up for me, since it does not say how a shift
updates the path. Does it add more nodes to it, or delete some?

>> la phrase "this child is the next node in the path" indique bien que le
>> chaque noeud dans le chemin est le fils du noeud précédent, i.e. le chemin
>> est une "branche". Pas de changement.

>> clarifié que quand on shifte, le chemin ne change pas.

Your point 3 is particularly hard to read, because it is too vague:
"some" (which?) child, "some" (which?) node, "corresponds" (in what way)
to the symbol. You also cannot have anything following a production in the
input stream, since the input stream contains no productions. You mean
the symbol sequence deriving from the production's right hand side.

>> clarifié que la pile correspond aux enfants à gauche, que l'input
>> non consommé correspond aux enfants à droite. Clarifié comment on
>> trouve le terminal "a". Ça reste très technique, mais il semble
>> difficile de faire mieux.

p14: point 3: there will be many format last nodes.

>> j'y crois pas: pinailler à ce point! j'ai eu du mal à comprendre ce
>> qu'il voulait dire (il y a plein "d'anciens dernier noeud"). Modifié
>> le texte.

I do not see how these operations on paths and invariant on paths (which I do
not understand, see above) help you, especially in the absence of an actually
implemented fully automatic oracle. You need a bit more discussion here.

>> done; new paragraph

p14: I don't think "the Coq development" means what you think it means.
I definitely do not know what you mean by "globally unsurprising".

>> fixed

p15: I would have thought the absence of support from later passes of CompCert
would be sufficient reason not to support K&R style functions; their obsolete
nature shouldn't matter.

>> il pinaille

Reference 18 is missing details.

>> fixed

