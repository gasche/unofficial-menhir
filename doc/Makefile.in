# WHAT IS Makefile.in USEFUL FOR
#
# The file `Makefile.in' is a pattern for creating a GNU Makefile
# which automates the build of LaTeX documents. This means first that
# it will take care for you of calling the proper and minimum number
# of time LaTeX until it reaches a fix-point or an error. Second, and
# most importantly, it displays a textual information on the build
# process, which is both concise and precise. In particular, a great
# amount of efforts has been devoted to get a clear warning and error
# reporting as well as specific hints to understand and solve the
# problem. The idea is to discharge almost completely the author of
# digging into the TeX log file. Nevertheless, since this makefile has
# been created by reverse-engineering -- and consequently works by means
# of heuristics --, not all cases are covered. We nevertheless expect it
# to be very helpful, in particular for beginners.
#
#
# HOW TO PROCESS IT
#
# The file `Makefile.in' must distributed together with its
# `configure.ac' file. The latter must be first processed by
# `autoconf', which produces a `configure' shell script. Then this
# script processes `Makefile.in' and produces the final `Makefile'. So
# the first thing to do is to make sure you have `autoconf' and
# `gmake' (the GNU version of Make) installed on your platform.
#
# We recommend to put both `Makefile.in' and `configure.ac', which
# must come together, in a fixed directory,
# e.g. ~/Std_makefiles/LaTeX. Then, the usual process is:
#
#  1) create the directory where you plan to put your LaTeX document, e.g.
#
#     ~$ mkdir My_paper
#
#  2) in this directory, make symbolic links to `Makefile.in' and
#     `configure.ac': 
#
#     ~$ cd My_paper
#     ~/My_paper$ ln -s ~/Std_makefiles/LaTeX/configure.ac
#     ~/My_paper$ ln -s ~/Std_makefiles/LaTeX/Makefile.in
#
#     This way, upgrading these files will be done in just one place.
#     If you control the versions of your sources under CVS or
#     Subversion, then write a simple shell script which performs the
#     above commands (symbolic linking) and check it in.
#  
#  3) Run `autoconf', which uses `configure.ac':
# 
#     ~/My_paper$ autoconf
#
#     This must create some files, among those a shell script `configure'.
#
#  4) Execute this script:
#
#     ~/My_paper$ ./configure
#
#     A possible output is:
#
# Autoconfiguration for building LaTeX documents
# (c) 2003-2006 Christian Rinderknecht
#                                                                         
# This is autoconf (GNU Autoconf) 2.57
# -----------------------------------------------------------------
# System tools
# checking for gmake... /usr/bin/gmake
# checking for perl... /usr/bin/perl
# checking for expr... /usr/bin/expr
# checking for sed... /bin/sed
# checking for awk... /usr/bin/awk
# checking for psnup... /usr/bin/psnup
# -----------------------------------------------------------------
# LaTeX and BibTeX
# checking for latex... /usr/bin/latex
# checking for bibtex... /usr/bin/bibtex
# -----------------------------------------------------------------
# Tools
# checking for ocamlweb... /home/rinderkn/bin/ocamlweb
# checking for dvips... /usr/bin/dvips
# checking for hevea... /home/rinderkn/bin/hevea
# checking for hacha... /home/rinderkn/bin/hacha
# checking for dvipdfm... /usr/bin/dvipdfm
# checking for dvipdf... /usr/bin/dvipdf
# checking for ps2pdf... /usr/bin/ps2pdf
# checking for pdftex... /usr/bin/pdftex
# -----------------------------------------------------------------
# Directories and paths
#   => The source directory is '.'
# configure: creating ./config.status
# config.status: creating Makefile
#
#     As you can see, this script searches your installation for some
#     software needed by the `Makefile' you are going to build. If some
#     listed software is found, it appears with its full path after the
#     dots, else it will be marked as 'none'. This does not always
#     imply that the final `Makefile' will not work properly, but that,
#     at least, some facilities will not work or not completely. In
#     case of a bug report, it will be important to keep a copy of the
#     output of `configure'.
#
# Then you can use `Makefile'.
#
#
# HOW TO USE THE FINAL MAKEFILE
#
# You must always call `make' in silent mode, i.e. with the `-s'
# option, and preferably with no built-in rules, i.e. with the option
# '-r', in order to gain performance. For instance, you should invoke
# `make -rs foo.ps'.
#
# The following targets are available (at least if the necessary tools
# have been found on your platform).
#
#   `info'
#
#    This phony target duplicates the documentation your are currently
#    reading from Makefile and put it in a file Makefile.info.
#
#   `dvi'
#
#   This target can be used only if you have one document in your
#   working directory. A document is a LaTeX file which contains a
#   \begin{document} definition. If there is no ambiguity (i.e. only one
#   document present) the DVI version of the document is created. The
#   file name will be the document filename whose `.tex' extension is
#   remplaced by `.dvi'. For example, if the document is `my_doc.tex',
#   then `make -rs dvi' will produce `my_doc.dvi'.
#
#   `ps'
#
#    This target is similar to `dvi', except that the PostScript version
#    of the document is built.
#
#   `pdf'
#
#    This target is similar to `dvi', except that the PDF version of the
#    document is built. Note that, depending on the tools available on
#    your platform, the PDF may be built by different means.
#
#   `4up_ps'
#
#    This target is similar to `ps', except that a 4up PostScript
#    version is built. This is useful for slides.
#
#   `4up_pdf'
#
#    This target is the PDF equivalent to `4up_ps' for PostScript.
#
#   `<document>.dvi'
#
#    This target is similar to `dvi', except it can be used even if
#    multiple documents share the same working directory. The document
#    must be named <document>.tex.
#
#   `<document>.ps'
#
#    This target is similar to <document>.dvi, except the PostScript
#    version of <document>.tex is built from <document>.dvi using
#    dvips.
#
#   `<document>.pdf'
#
#    This targer is similar to <document>.dvi, except the PDF version
#    of <document>.tex is built, either from <document>.tex,
#    <document>.dvi or <document>.ps, depending on the configured
#    tools.
#
#   `<document>-4up.ps'
#
#    This target is similar to `4up_ps', except it works even if
#    multiple documents share the same working directory.
#
#   `<document>-4up.pdf'
#
#    This target is similar to `4up_pdf', except it works even if
#    multiple documents share the same working directory.
#
#   `all'
#
#    This target is equivalent to `ps'.
#
#   `mostlyclean'
#
#    This phony target always removes the document dependences
#    (i.e. removes the hidden administrative .dep directory).  If
#    variable DOC is defined (see below), then the update of this
#    target also removes the DVI files, the document PostScript and
#    PDF files (including 4-up ones and the excerpts), the document
#    BibTeX files .bbl and .blg, the document TeX auxiliary files
#    .aux, the document table of contents files .toc, the document TeX
#    log files .log, the hidden control files .built-pdf,
#    .out-of-date, .errors, .errmsg and .excerpts. 
#
#    Use it in conjunction with `VERB=yes' to get the detail of the
#    erased files (but not control files).
# 
#    What is not removed are the files relative to the figures.
#
#    For a subtle interaction with target `clean' see section about
#    `clean'.
#
#   `clean'
#
#    This target cleans all the files produced by LaTeX, BibTeX and
#    special files created by `Makefile' (like <document>.dvi0 and
#    `Makefile.bbl', if any). Files related to the figures are deleted
#    (except sources, of course). 
#
#    Use it in conjunction with `VERB=yes' to get the detail of the
#    erased files (but not control files).
#
#    Note: do not update phony target `mostlyclean' and then `clean'
#    because the former removes the dependences so `clean' becomes
#    very conservative. Therefore, if you updated `mostlyclean' and
#    now whish to update `clean' try `make -rs dep clean'.
#
#   `distclean'
#
#    This target do all what `clean' do, plus removes all the
#    configuration files created by `autoconf' and `./configure' and
#    possible emacs backups. This target is useful when you want to
#    distribute your document.
#
#
# Finally, if there is no target (`make -rs'), it is equivalent to 
# `make -rs all'.
#
#
# DEBUGGING OPTIONS
#
# The following phony targets are use for debugging purposes, hence
# are not for the casual user.
#
#   `env'
#
#    Prints the values of the makefile variables.
#
#   `files'
#
#    This phony target triggers an analysis of the TeX sources and
#    gives the names of the files needed to build your document. Note
#    that this list is built statically, so, in general, it is an
#    over-approximation.
#
#   `graphics'
# 
#    This phony target is similar to `files' except it reports
#    exclusively the included graphics (via the \includegraphics macro
#    call). It is also a static analysis, so it is an
#    over-approximation in general.
#
#   `biblio'
#
#    Updating this phony target creates a <name>.biblio file for each
#    <name>.tex, containing the bibliographies they include through the 
#    use of BibTeX. These files are hidden in the .dep directory.
#
#   `dep'
#
#    Updating this phony target creates a <name>.dep file for each
#    <name>.tex file, containing the file dependences.
#
#   `pretty'
#
#   XXXX
#
# You can get all the phony targets of the makefile by running:
#
#   ~/My_paper$ make env | grep PHONY_TARGETS
#   
#
# SLIDES
#
# AutomaTeX promotes the usage of document class `seminar' for creating
# slides, otherwise you will not get any special support from AutomaTeX.
#
#
# SEVERAL DOCUMENTS
#
# AutomaTeX supports the construction of several standalone documents
# in the same working directory. In this case you should specify the
# name of the target, either explicitly or through the GNU Make
# variable DOC (see USER DEFINED VARIABLES and HOW TO CONFIGURE ALL
# MAKE INVOCATIONS sections).
#
# Note that if a document is included in another one through an
# \includegraphics macro call (see FIGURES section), it will always be
# considered as a figure, therefore a tight bounding box will be
# produced by `dvips' (see option -E), even if the file extension is
# `.ps' (and not `.eps') and the bounds are not so tight as one could
# expect (see FIGURES section for manually setting the bounds).
#
# If you use WhizzyTeX, AutomaTeX will ignore the administration file
# of WhizzyTeX, that will not be considered as separate documents.
#
#
# FIGURES
#
# AutomaTeX provides automatic support for figure inclusion. 
#
# A figure is a document that can be included by another by means of a
# call the \includegraphics macro of the package `graphicx'. What is a
# figure is determined statically by parsing the TeX files (so,
# theoritically, it is an over-approximation).
#
# The figures should lie in the same directory as the main
# document. AutomaTeX takes care of determining which are the figures
# to build and build the corresponding PostScript (or Encapsulated
# PostScript) files before building the main document where they are
# included.
#
# If a figure is built from a TeX file, its extension will be `.ps'
# (even if it is an Encapsulated PostScript), otherwise, if it is
# converted from another graphic format, as Fig (`.fig') or GIF
# (`.gif'), the extension will be `.eps'.
#
# If figures are to be built by converting one image format to
# Encapsulated PostScript, please refer to the LIMITATIONS section.
#
# The bounding box of a figure created from a TeX file may not be as
# tight as expected. In such case, change the parameters of the box
# in the line in the Encapsulated PostScript that starts with
# `%%BoundingBox:' and watch the result in a viewer (e.g. use `gv' or
# `ggv' with the `Watch file' option enabled). Once you are satisfied
# with the bounds, you can create a <figure>.bbx file, where <figure>
# is the file basename of the figure TeX file, containing this
# complete line, for instance: `%%BoundingBox: 66 600 260 740'. This
# way, AutomaTeX will automatically patch the corresponding PostScript
# each time it is updated.
#
# It is recommended that the figures fit in a single page (so `dvips
# -E' has a chance to work).
#
#
# USER-DEFINED VARIABLES
#
# When invoking GNU Make on this makefile, you can define some
# variables to change the behaviour of this makefile.
#
#   `PP'
#
#    This command-line option allows you to specify the page range 
#    you want to build. For instance
#
#    make -rs pdf PP=5-13
#
#    builds the PDF version of your document for page numbers 
#    ranging from 5 to 13 (included). The resulting file is named
#    <document>-5-13.pdf. 
#
#    Open upper bound is allowed:
#
#    make -rs pdf PP=6-
#
#    produces '<document>-6-.pdf', which includes pages from number 6
#    to the last.
#
#    Open lower bounds are _not_ allowed.
#
#    Multiple ranges are allowed:
#
#    make -rs pdf PP='2-4 7-11'
#
#    produces '<document>-2-4,7-11.pdf'
#
#   `VERB'
#
#    This variable is by default `no'. If set to `yes' on the
#    command-line invoking GNU Make on this makefile, detailed
#    informations will be displayed, including: updating of
#    dependences (between TeX files and between TeX files and BibTeX
#    files), Make recursive calls and some commands calls. Each call
#    is exactly as it is passed to the underlying shell and it is
#    prefixed by a unique tag made of an hexadecimal number between
#    `<' and `>'.
#
#   `DEBUG'
#
#    Set `DEBUG=yes' in the command-line to get debug info like
#    uniquely-numbered check-points. Can be used in conjunction with
#    `VERB=yes'. For desperate users only.
#
#   `DOC'
#
#    It is possible to specify the file basenames of the main
#    documents to be built, in case there are several main documents
#    in the same working directory.
#
#   `LOCAL'
#
#    By default, AutomaTeX follows the symbolic links when analysing a
#    set of TeX files. In case you do not want this behaviour, e.g. in
#    order to save time, you can set the variable LOCAL to `yes'
#    either on the command-line or, better, in `Makefile.cfg'. Default
#    value is `no'.
#
#   `DVIPS_COMMON_OPT'
# 
#    You can pass options to `dvips' through this variable, for all
#    invocations. In case AutomaTeX is building a figure, the option
#    `-E' is transparently added (`dvips' attempts to generate an
#    Encapsulated PostScript file with a tight bounding box on
#    one-page files). Default value is the empty string.
#
#   `HREF_PDF'
#
#    XXX
#
#   `PDF_MAKER'
#
#    You can force the software which makes the PDF file by setting
#    this variable to the full path of the binary: you can either
#    choose `dvipdf', `dvipdfm' or `ps2pdf' as basenames. If you
#    request a programme which has not been configured, a warning is
#    issued and the content of this variable is ignored.
#
#    `TALK'
#    
#    If you are using package `seminar', `prosper' or `beamer', this
#    variable will automatically be set to the name of the package you use. 
#    If you are using another package for writing presentations, you
#    should can set this variable to the name of the package you
#    use. This is important, in particular for passing the proper
#    options to `dvips' and `ps2pdf', like paper size. Otherwise this
#    variable is set to the empty string. 
#
#    Note that the slides will be produced in landscape and A4 when
#    using `dvipdfm' and `ps2pdf' (i.e. GhostScript) to make PDF.
#
#   `PAPER'
# 
#    If variable TALK is not empty, AutomaTeX assumes that you are
#    updating a presentation (i.e. slides) XXX
# 
#
# HOW TO CONFIGURE ALL MAKE INVOCATIONS
#
# `Makefile.cfg' XXX
#
#
# SIMPLE EXAMPLE
#
# ~/My_paper$ make -rs
# Making cj2003.dvi from cj2003.tex... done (20 pages, 198884 bytes).
# Processing bibliography biblio.bib of cj2003.tex... done (16 entries).
# Merging document and bibliography... done (21 pages, 203568 bytes).
# Recompiling document to solve citations... done (21 pages, 203508 bytes).
#   [W] 23 horizontal overfulls.
#   [W] 14 horizontal underfulls.
#   [W] 2 vertical underfulls.
#       => Rerun make for details or check cj2003.log for transcript.
# Making cj2003.ps from cj2003.dvi... done (21 pages, 741399 bytes).
#
#
# WARNINGS, ERRORS AND HINTS
#
# Warnings are introduced by "[W]" and errors by "[E]". Hints to solve
# the problems are introduced by "=>". 
# The recommended way to deal with these informations is to correct
# errors first, because some warnings may come from previous errors.
# Note that only the first error is reported.
#
#
# DETAILED STATUS OF THE DOCUMENT
#
# In case overfulls and underfulls happened, a summary is printed (see
# example above). If you want to have the details, re-run the same
# `make' command on an up-to-date document.
#
# ~/My_paper$ make -rs
# Document cj2003.ps is up-to-date.
#   [W] Overfull \hbox (4.58812pt) in core_asn1.tex at lines 181--198.
#       => Check page 4 and line 260 in cj2003.log.
#   [W] Underfull \hbox (badness 10000) in core_asn1.tex at lines 322--333:
#       The de-fault val-ues are ex-panded, like
#       => Check page 4 and line 265 in cj2003.log.
#
# etc.
# TeX font changes in line excerpts are squeezed as well as
# math environments (e.g. $...$ becomes <maths>) to increase readability.
#
# You are also reminded of the other errors and warnings.
#
#
# IT SUPPORTS IN PARTICULAR...
#
#   Inclusion of figures through \includegraphics
#   BibTeX bibliographies (\bibliographystyle and \bibliography).
#   Table of contents (\tableofcontents).
#   Labels (\label) and references (\ref), even from bibliographies.
#   Citations (\cite), even inside bibliographies.
#   Package `chapterbib' (i.e. one BibTeX bibliography per chapter).
#
#
# LIMITATIONS
#
#   In case you add an \includegraphics call on a figure which
#   requires a convertion from another graphic format, you must run
#     ~/My_paper$ make -rs mostlyclean
#   in order to remove the previous dependences and force a
#   recomputation by
#     ~/My_paper$ make -rs <your targets>
#   
#   No support of lists of figures (\listoffigures macro, `.lof' file) 
#   No support of lists of tables (\listoftables macro, `.lot' file).
#   No support of indexes.
#   No support for HTML output.
#   No support for RTF output.
#   Long error messages (more than one line) in `.blg' are not handled.
#
#
# IF SOME FILENAME LOOKS STRANGE
# 
# In case of warning or error, it may happen that the filename look
# strange. This is because the run of `make' when the document is not
# up-to-date uses a (relatively) fast heuristics which can not be
# accurate in all cases. It is recommended then to re-run `make'
# (i.e. when the document is up-to-date) because it will use a more
# accurate, though slower, heuristics.
#
#
# BIBLIOGRAPHIES
#
# AutomaTeX promotes the usage of bibliographies specified by means of
# `.bib' files (to be processed with BibTeX), instead of user-defined
# \bibitem macro calls. The makefile also supports package
# `chapterbib', which allows the inclusion of a bibliography per
# chapter in a book.
#
#
# REMARK
#
# If you want `configure' to be quiet, type 
#
# ~/My_paper$ ./configure -q > /dev/null
# 
#
# ADVANCED USAGE
#
# You may already have your own specialized makefile but you would
# like to enjoy some useful features offered by this one. This is
# indeed possible as described in section "Overriding Part of Another
# Makefile" when you type `info make'. Just rename your makefile as
# `GNUmakefile' or `makefile' (this makefile must keep its original
# name `Makefile') and override this one in it. This way your makefile
# will be called by default by `make'.
#
#
# BUG REPORT
#
# Before sending a bug report to Christian.Rinderknecht@devinci.fr,
# please get
#
#   1) the terminal output of `./configure',
#   2) the smallest document that shows the bug,
#   3) the output of `make env',
#   4) the terminal output of `make -rs <your target>',
#   5) the terminal output of `make -r <your target>',
#   6) the TeX log file <document>.log.
#
# [END DOC]

# $Id: Makefile.in,v 1.2 2008/02/01 20:06:42 fpottier Exp $

# ========================================================================
# Header
#
# We want a POSIX-compliant behaviour
#
.POSIX:

# Check for "g*" prefixed GNU coreutils.
#
MKDIR := @MKDIR@
MV := @MV@
CP := @CP@
CAT := @CAT@
TR := @TR@
UNIQ := @UNIQ@
SED := @SED@
SORT := @SORT@
HEAD := @HEAD@
TAIL := @TAIL@
WC := @WC@
AWK := @AWK@
LS := @LS@
EXPR := @EXPR@
PERL := @PERL@
ECHO := @ECHO@
PASTE := @PASTE@
CUT := @CUT@
NL := @NL@

# Make implementation must be GNU Make (see `configure.ac').
#
MAKE := @MAKE@

# We want `bash' for executing commands.
#
SHELL := @SHELL@

# XXX
#
HREF_PDF ?=#

# Java
#
JAVA := @JAVA@

# Saxon
#
SAXON := @SAXON@

# xmllint
#
XMLLINT := @XMLLINT@

# Erlang
#
ERLC := @ERLC@

#
#
FRAG ?= low

# Converting graphics formats
#
PSNUP := @PSNUP@
FIG2DEV := @FIG2DEV@
CONVERT := @CONVERT@
JPEG2EPS := @JPEG2EPS@

# Making DVI
#
LATEX := @LATEX@
LATEX_OPT :=-shell-escape#

# Making bibliographies
#
BIBTEX := @BIBTEX@

# Making PostScript
#
DVIPS := @DVIPS@

BZIP2 := @BZIP2@
TAR := @TAR@

# ========================================================================
# Error record and display
# 
signal_error = \
  ${ECHO} ${1}; \
  ${ECHO} ${1} >> .E

# ========================================================================
# Main (default) phony target
#
# Note: If you plan to change the prerequisites of target `all', you
# must change consistently the substitution in sequence
# `collect_generic_goals'.
#
all: ps

# ========================================================================
# Sub-makefile updating
#
sinclude Makefile.cfg

# ========================================================================
# LaTeX Prologue
#
DEF :=#
override PROLOGUE := "\batchmode${DEF}\listfiles\input"

# ========================================================================
# Making PDF
#
PDF_MAKER ?=#

ifeq (${PDF_MAKER},dvipdf)
  ifneq (@DVIPDF@,none)
    DVIPDF := @DVIPDF@
    DVIPDFM :=none
    PS2PDF :=none
    PDFTEX :=none
  else
    ${warning You request dvipdf but it is not configured. Ignored.}
  endif
else
  ifeq (${PDF_MAKER},dvipdfm)
    ifneq (@DVIPDFM@,none)
      DVIPDF :=none
      DVIPDFM := @DVIPDFM@
      PS2PDF :=none
      PDFTEX :=none
    else
      ${warning You request dvipdfm but it is not configured. Ignored.}
      DVIPDF := @DVIPDF@
      DVIPDFM := @DVIPDFM@
      PS2PDF := @PS2PDF@
      PDFTEX := @PDFTEX@
    endif
  else
    ifeq (${PDF_MAKER},ps2pdf)
      ifneq (@PS2PDF@,none)
        DVIPDF :=none
        DVIPDFM :=none
        PS2PDF := @PS2PDF@
        PDFTEX :=none
      else
        ${warning You request ps2pdf but it is not configured. Ignored.}
        DVIPDF := @DVIPDF@
        DVIPDFM := @DVIPDFM@
        PS2PDF := @PS2PDF@
        PDFTEX := @PDFTEX@
      endif
    else
      ifeq (${PDF_MAKER},pdftex)
        ifneq (@PDFTEX@,none)
          DVIPDF :=none
          DVIPDFM :=none
          PS2PDF :=none
          PDFTEX := @PDFTEX@
        else
          ${warning You request pdftex but it is not configured. Ignored.}
          DVIPDF := @DVIPDF@
          DVIPDFM := @DVIPDFM@
          PS2PDF := @PS2PDF@
          PDFTEX := @PDFTEX@
        endif
      else
        DVIPDF := @DVIPDF@
        DVIPDFM := @DVIPDFM@
        PS2PDF := @PS2PDF@
        PDFTEX := @PDFTEX@
      endif
    endif
  endif
endif

# Making HTML
#
HEVEA := @HEVEA@

OCAMLWEB := @OCAMLWEB@

UPDATE := no
FAKE := no
LOC ?=#

SILENT :=#

INCL_DEP := no
KEEP_DEP := no
INCL_BIBLIO := no

# By default we do not want verbose output (mainly for debug
# purposes).
#
VERB :=#
DEBUG :=#

ifeq (${MAKELEVEL},0)
${shell ${RM} --force .errmsg .E}
endif

# ========================================================================

subset = \
  sorted_2=$$(${ECHO} ${2} \
              | ${TR} ' ' '\n' \
              | ${SORT} --dictionary-order \
              | ${UNIQ} \
              | ${TR} '\n' ' '); \
  merger=$$(${ECHO} ${1} ${2} \
            | ${TR} ' ' '\n' \
            | ${SORT} --dictionary-order \
            | ${UNIQ} \
            | ${TR} '\n' ' '); \
  if test "$$merger" = "$$sorted_2"; \
  then \
    ${ECHO} yes; \
  else \
    ${ECHO} no; \
  fi

# DO NOT USE `${SORT} --unique' because it identifies `x_y.ps' and `xy.ps'.
#
sort_string = \
  $$(${ECHO} ${1} \
     | ${TR} ' ' '\n' \
     | ${SORT} --dictionary-order \
     | ${UNIQ} \
     | ${TR} '\n' ' '\
     | ${TR} --squeeze-repeats ' ')


# ========================================================================

.PRECIOUS: %.dvi %.dvi0 %.aux %.bbl %.ps %.html %.pdf %.tex

%.cls: ;
%.sty: ;
%.tex: ;
%.bib: ;


# Needed for %.dep rule.
%.log: ;

# ========================================================================
# Directories and Paths


# The directory for the compilation and linkage dependences is
# ${DEPDIR}.
#
override DEPDIR := .dep#

# The sequence ${DEPDIR_EXISTS} is a predicate about the existence of
# the directory containing the dependences, ${DEPDIR}.
#
override DEPDIR_EXISTS := \
  ${shell if test -n "${DEPDIR}" -a -d "${DEPDIR}"; \
          then ${ECHO} yes; \
          else ${ECHO} no; fi}

# The sequence ${ensure_DEPDIR} creates the directory ${DEPDIR} if it
# does not exists and does nothing otherwise.
#
override ensure_DEPDIR =#
ifeq (${DEPDIR_EXISTS},no)
  ifneq (${DEPDIR},)
override ensure_DEPDIR = ${MKDIR} --parents ${DEPDIR}
  endif
endif

# The directory for exporting a document together with its sources
# plus a customized Makefile is ${DISTDIR}
#
override DISTDIR := dist#

# Some directory names are reserved for avoiding clashes.
#
override RESERVED_NAMES := doc src ${DISTDIR}

# XXX
#
override pref_depdir = ${addprefix ${DEPDIR}/,${notdir ${1}}}
override depdir_qualif = ${notdir ${1}} ${call pref_depdir,${1}}

# XXX
#
vpath %.dep ${DEPDIR}
vpath %.pkg ${DEPDIR}
vpath %.biblio ${DEPDIR}
vpath %.tex .
vpath %.log .


# ========================================================================
# Master documents

# Variable PHONY_TARGETS lists all the phony targets of this
# makefile. It is useful to avoid name clashes (with a
# binary). Display through the phony target updating `env'.
#
override PHONY_TARGETS := \
${sort ${shell ${SED} --quiet "s|^\([-_[:alnum:]]\+\):.*|\1|p" Makefile}}

#override PHONY_GOALS := \
#  ${strip ${filter ${PHONY_TARGETS},${MAKECMDGOALS}}}

# Some filtering is needed to reject some ambiguous or erroneous cases.
#
# override PERI_GOALS := clean% %clean env info

# override FILTERED_PERI_GOALS := \
#   ${strip ${filter ${PERI_GOALS},${MAKECMDGOALS}}}

# override FILTERED_MAIN_GOALS := \
#   ${strip ${filter-out ${PERI_GOALS},${MAKECMDGOALS}}}

# Variable PRESENT_TEX holds all the TeX files.
# XXX
override PRESENT_TEX := \
  ${filter-out _whizzy%,${notdir ${wildcard *.tex}}}

# Variable PRESENT_DOC_TEX holds all the master TeX files.
#
ifneq (${PRESENT_TEX},)
override PRESENT_DOC_TEX := \
  ${strip \
    ${notdir \
      ${shell grep --files-with-matches \
                   '^ *\\begin[{]document[}]' \
                   ${PRESENT_TEX} \
                   2> /dev/null}}}

override PRESENT_DOC := ${strip ${basename ${PRESENT_DOC_TEX}}}
endif

DOC ?=#

PP ?=#
PAGES := ${strip ${shell ${ECHO} ${if ${PP},-${PP}} | ${TR} ' ' ','}}#
override 4UP := -4up#

override DVIPS_OPT += ${if ${PP},${addprefix -pp ,${PP}}}
override DVIPDFM_OPT += ${if ${PP},-s ${PP}}

DVIPS_COMMON_OPT ?=#

ifeq (${strip ${DVIPS_COMMON_OPT}},)
override DVIPS_FIG_OPT += -E
else
override DVIPS_OPT += ${DVIPS_COMMON_OPT}
override DVIPS_FIG_OPT += ${DVIPS_COMMON_OPT} -E
endif

# ${sort ...} must NOT be indented (otherwise the leftmost blanks would be
# added to the definition.
#
ifeq (${DOC},)
  define collect_generic_goals
${sort \
    ${if ${filter ${1},${patsubst all,ps,${MAKECMDGOALS}}}, \
         ${PRESENT_DOC:%=%${2}.${1}}}}
  endef
else
  define collect_generic_goals
${sort \
    ${if ${filter ${1},${patsubst all,ps,${MAKECMDGOALS}}}, \
         ${DOC:%=%${2}.${1}}}}
  endef
endif

define collect_defined_goals
${sort \
    ${filter %.${1},${MAKECMDGOALS}}}
endef

ifeq (${DOC},)
  define collect_4up
${sort \
      ${if ${filter 4up_${1},${MAKECMDGOALS}}, \
           ${PRESENT_DOC:%=%${4UP}${PAGES}.${1}}, \
           ${filter %${4UP}${PAGES}.${1},${MAKECMDGOALS}}}}
  endef
else
  define collect_4up
${sort \
      ${if ${filter 4up_${1},${MAKECMDGOALS}}, \
           ${DOC:%=%${4UP}${PAGES}.${1}}, \
           ${filter %${4UP}${PAGES}.${1},${MAKECMDGOALS}}}}
  endef
endif


ifeq (${MAKECMDGOALS},)
  ifeq (${DOC},)
override PS := ${PRESENT_DOC:%=%${PAGES}.ps}
override PDF :=#
override 4UPPS :=#
override 4UPPDF :=#
override DVI := ${PRESENT_DOC:%=%.dvi}
override TEX := ${PRESENT_DOC_TEX}
DOC := ${PRESENT_DOC} 
  else # DOC is defined
override PS := ${DOC:%=%${PAGES}.ps}
override PDF :=#
override 4UPPS :=#
override 4UPPDF :=#
override DVI := ${DOC:%=%.dvi}
override TEX := ${DOC:%=%.tex}
  endif
else # There is at least one target
override PS := \
${sort \
      ${filter-out %${4UP}${PAGES}.ps, \
                   ${call collect_defined_goals,ps}} \
      ${call collect_generic_goals,ps,${PAGES}}}
override PDF := \
${sort \
      ${filter-out %${4UP}${PAGES}.pdf, \
                   ${call collect_defined_goals,pdf}} \
      ${call collect_generic_goals,pdf,${PAGES}}}
override 4UPPS := ${call collect_4up,ps}
override 4UPPDF := ${call collect_4up,pdf}
override DVI := \
${sort \
      ${call collect_defined_goals,dvi} \
      ${call collect_generic_goals,dvi,} \
      ${if ${PAGES}, \
           ${patsubst %.ps,%.dvi,${PS:${PAGES}.ps=.dvi}}, \
           ${PS:.ps=.dvi}} \
      ${if ${PAGES}, \
           ${patsubst %.pdf,%.dvi,${PDF:${PAGES}.pdf=.dvi}}, \
           ${PDF:.pdf=.dvi}} \
      ${4UPPS:${4UP}${PAGES}.ps=.dvi} \
      ${4UPPDF:${4UP}${PAGES}.pdf=.dvi}}
  ifeq (${DVI},)
    ifeq (${DOC},)
      override DOC := ${PRESENT_DOC}
    endif
  else
    ifeq (${DOC},)
      override DOC := ${basename ${DVI}}# Mandatory overriding
    else
      override DOC := ${sort ${DOC} ${basename ${DVI}}}# Mandatory overriding
    endif
  endif
  override TEX := ${DOC:%=%.tex}
endif

# Sorting ${DOC} is important in order to simplify set inclusion
# involving DOC.
# 
override DOC := ${sort ${DOC}}

ifeq (${DEBUG},yes)
  ${warning 4UPPS  = [${4UPPS}]}
  ${warning 4UPPDF = [${4UPPDF}]}
  ${warning DOC    = [${DOC}]}
  ${warning DVI    = [${DVI}]}
  ${warning PS     = [${PS}]}
  ${warning PDF    = [${PDF}]}
  ${warning TEX    = [${TEX}]}
  ${warning PAGES  = [${PAGES}]}
endif

ifneq (${DOC},)
${foreach document, ${DOC}, \
  ${if ${findstring ${document},${PRESENT_DOC}},, \
       ${error Document ${document}.tex not found}}}
endif

ifeq (${DOC},)
PARTS :=#
else
PARTS := ${addsuffix .pp,${DOC}}
endif

# In case we debug the previous variables, uncomment the following.
#
#${error }

# By default, AutomaTeX follows the symbolic links when analysing a
# set of TeX files. In case we do not want this behaviour, e.g. in
# order to save time, we can set the variable LOCAL to `yes'
# either on the command-line or, better, in `Makefile.cfg'.
#
LOCAL ?= no

ifeq (${LOCAL},yes)
LOCAL_TEX := \
  ${filter-out _whizzy%,\
     ${notdir ${shell find . -maxdepth 1 -type f -name '*.tex'}}}
DEP := ${LOCAL_TEX:%.tex=%.dep}
BIBLIO := ${LOCAL_TEX:%.tex=%.biblio}
else
DEP := ${PRESENT_TEX:%.tex=%.dep}
BIBLIO := ${PRESENT_TEX:%.tex=%.biblio}
endif

AUX := ${DOC:%=%.aux}
LOG := ${DOC:%=%.log}
LOG1 := ${DOC:%=%.log1}
DVI0 := ${DOC:%=%.dvi0}
TOC := ${DOC:%=%.toc}
LOF := ${DOC:%=%.lof}

find_opt = \
  ${SED} --quiet \
    's/^ *\\usepackage\[\(.*\)\]\([{].*,\|[{]\)${1}\(,.*\|[}]\)/\1/p' \
    ${TEX} 2> /dev/null \
 | ${TR} ',' ' '

is_in = \
  in="false"; \
  for opt in $$options; do \
    if test "$$opt" = "$$sought"; then in="true"; break; fi \
  done

ifeq (${DOC},)
  DOC_CLASS :=#
  PACKAGES :=#
else
  DOC_CLASS := \
    ${shell ${SED} --quiet \
                's|^ *\\documentclass\(\[\(.*\)\]\)\?[{]\(.*\)[}]|\3|p' \
                ${DOC:%=%.tex} 2> /dev/null}

  PACKAGES := ${sort \
         $(shell ${SED} --quiet \
             's|^ *\\usepackage\(\[.*\]\)*[{]\(.*\)[}]|\2|p' \
             ${DOC}.tex 2> /dev/null \
           | ${TR} ',' ' ' 2> /dev/null)}
endif

OCW := ${filter ocamlweb,${PACKAGES}}
TIMES := ${filter times,${PACKAGES}}
AE := ${filter ae,${PACKAGES}}
FONTENC := ${filter fontenc,${PACKAGES}}
AMSSYMB := ${filter amssymb,${PACKAGES}}
AMSMATH := ${filter amsmath,${PACKAGES}}
AMSFONTS := ${filter amsfonts,${PACKAGES}}
PSTRICKS := ${filter pstricks,${PACKAGES}}
VAUCANSON := ${filter vaucanson-g,${PACKAGES}}
ifneq (${VAUCANSON},)
  ifeq (${PSTRICKS},)
PSTRICKS := pstricks
  endif
endif
GRAPHICS := ${filter graphics,${PACKAGES}}
GRAPHICX := ${filter graphicx,${PACKAGES}}
HYPERREF := ${filter hyperref,${PACKAGES}}
MAKEIDX := ${filter makeidx,${PACKAGES}}
TOCBIBIND := ${filter tocbibind,${PACKAGES}}

TALK := ${filter seminar beamer prosper,${PACKAGES} ${DOC_CLASS}}

ifeq (${TALK},)
PAPER ?= a4
override DVIPS_OPT += -t ${PAPER}
override DVIPDFM_OPT += -p ${PAPER}
override PS2PDF_OPT += -sPAPERSIZE=${PAPER}
else
PAPER :=#
# Landscape orientation for PDF in case of talk.
override DVIPDFM_OPT += -l
override PS2PDF_OPT += -sPAPERSIZE=a4
endif

override DVIPS_OPT := ${strip ${DVIPS_OPT}}
override DVIPDFM_OPT := ${strip ${DVIPDFM_OPT}}

# Il faut d'abord mettre en place l'usage de `pdftex', puis prevoir
# l'analyse des options du paquetage `graphics'.
# ifeq (${DVIPDFM},none)
#   ifneq (${PDFTEX},none)
#     ifneq (${GRAPHICS},)
#       ifneq (${GRAPHICS_OPT},pdftex)
#         ${warning Use \usepackage[pdftex]{graphics}.}
#       endif
#     endif
#   endif
# # Quid des options [dvips] et [xdvi] pour graphics??
# endif

# Il faut d'abord mettre en place l'usage de `pdftex' et `ps2pdf',
# puis prevoir l'analyse des options du paquetage `hyperref'.
# 
#HYPERREF_OPT := ${call shell_find_opt,hyperref}
#
# ifneq (${HYPERREF},)
#   ifeq (${DVIPDFM},none)
#     ifneq (${PDFTEX},none)
#       ifneq (${HYPERREF_OPT},pdftex)
#         ${warning Use \usepackage[pdftex]{hyperref}.}
#       endif
#     else
#       ifneq (${PS2PDF},none)
#         ifneq (${HYPERREF_OPT},dvips)
#           ${warning Use \usepackage[dvips]{hyperref}.}
#         endif
#       endif
#     endif
#   endif
# endif

ifeq (${TEX},)
TABLE_OF_CONTENTS :=#
TOC_WARNING :=#
else
TABLE_OF_CONTENTS := \
  ${shell grep '^ *\\tableofcontents' ${TEX} 2> /dev/null}
  ifneq (${TABLE_OF_CONTENTS},)
    ifeq (${TOCBIBIND},)
TOC_WARNING := "  [W] Use \usepackage[nottoc]{tocbibind} to get the table of contents right."
    else
TOC_WARNING :=#
    endif
  else
TOC_WARNING :=#
  endif

endif

ifneq (${AE},)
  PRINTER :=-Ppdf
else
  PRINTER :=#
endif

# AMS := $(shell ${SED} --quiet \
# 's/^ *\\usepackage\(\[.*\]\)*\([{].*,\|[{]\)\(ams\([^,]*\)\).*[}]/\3/p'\
# ${TEX} 2> /dev/null)

num_of = $$(${ECHO} $$${1} | ${WC} --words | ${TR} --delete ' ')

item_series = \
  case $$(${ECHO} ${1} | ${WC} --words | ${TR} --delete ' ') in \
    0|"") ;; \
    1) ${ECHO} ${1};; \
    2) ${ECHO} ${1} | ${SED} 's| | and |g';; \
    *) ${ECHO} ${1} | ${SED} 's| |,|g';; \
  esac

GENDOC := gen-doc

# ------------------------------------------------------------------------
# Time stamps
#
record_time_stamp = \
  if test -e "${1}"; \
  then \
    date '+%d %B %Y' >| ${dir ${1}}.${notdir ${1}}.date; \
  fi

# ------------------------------------------------------------------------
# Bibliographies
#
SET_slave_tex = \
  slave_tex=$$(if test -e ${call pref_depdir,${1}.dep}; \
               then \
                 grep ${1}.dvi:: ${call pref_depdir,${1}.dep} \
               | ${TR} ' ' '\n' \
               | grep \.tex \
               | while read tex_file; do \
                   if test $$tex_file != ${1}; \
                   then \
                     ${ECHO} $$tex_file; \
                   fi; \
                 done; \
               fi)

SET_slave_bbl = \
  slave_bbl=$$(if test -e ${call pref_depdir,${1}.dep}; \
               then \
                 ${CAT} ${call pref_depdir,${1}.dep} \
               | ${TR} ' ' '\n' \
               | ${SED} --quiet 's|\(.*\.bbl\)|\1|p'; \
               fi)

SET_slave_bib = \
  slave_bib=$$(if test -e ${call pref_depdir,${1}.dep}; \
               then \
                 ${CAT} ${call pref_depdir,${1}.dep} \
               | ${TR} ' ' '\n' \
               | ${SED} --quiet 's|\(.*\)\.bbl|\1.bib|p'; \
               fi)

SET_slave_base_blg = \
  slave_base_blg=$$(if test -e ${call pref_depdir,${1}.dep}; \
                    then \
                      ${CAT} ${call pref_depdir,${1}.dep} \
                    | ${TR} ' ' '\n' \
                    | ${SED} --quiet 's|\(.*\)\.bbl|\1|p'; \
                    fi)

ALL_BIB := ${notdir ${wildcard *.bib}}
ALL_BST := ${notdir ${wildcard *.bst}}

override SLAVE_TEX := \
  ${strip ${filter-out ${PRESENT_DOC_TEX}, ${PRESENT_TEX}}}

override DOC_AND_SLAVE_TEX := \
  ${strip ${DOC:%=%.tex} ${SLAVE_TEX}}

# BST_BASENAME := \
#   ${shell ${SED} --quiet 's|^ *\\bibliographystyle[{]\(.*\)[}].*|\1|p' \
#                       ${DOC_AND_SLAVE_TEX}}

# TEMPORARY
ifneq (${DOC_AND_SLAVE_TEX},)
BIB_BASENAMES := \
${sort \
  ${shell ${SED} --quiet 's|^ *\\bibliography[{]\([^{%} ]\+\)[}].*|\1|p' \
                      ${DOC_AND_SLAVE_TEX} \
          | ${TR} ',' ' '}}

BIB := ${addsuffix .bib, ${BIB_BASENAMES}}
PRESENT_BIB := ${sort ${filter ${BIB}, ${ALL_BIB}}}
MISSING_BIB := ${sort ${filter-out ${PRESENT_BIB}, ${BIB}}}
TEX_WITH_BIB := \
    ${shell \
        grep --files-with-matches '^ *\\bibliography[{][^{%} ]\+[}].*' \
             ${DOC_AND_SLAVE_TEX}}
endif
BBL := ${TEX_WITH_BIB:.tex=.bbl}
BLG := ${BBL:.bbl=.blg}

#   ifneq (${MAKECMDGOALS},clean)
#     ifneq (${MAKECMDGOALS},distclean)
#       ifneq (${MAKECMDGOALS},mostlyclean)
#         ifneq (${MISSING_BIB},)
#         TEX_TO_CHECK := \
#           ${foreach MY_BIB,${MISSING_BIB:.bib=},${shell grep --files-with-matches '^ *\\bibliography[{]\(.*,\|\)${MY_BIB}\(,.*\|[}]\)' ${DOC_AND_SLAVE_TEX}}}
#           ifeq (${words ${MISSING_BIB}},1)
#           ${warning Bibliography ${MISSING_BIB} is missing.}
#           ${error Make it available or check the spelling in \
#                   ${shell ${call item_series,${TEX_TO_CHECK}}}}
#           else
#           ${warning Bibliographies \
#             ${shell ${call item_series,${MISSING_BIB}}} are missing.}
#           ${error Make them available or check the spellings in \
#             ${shell ${call item_series,${TEX_TO_CHECK}}}}
#           endif
#         endif
#       endif
#     endif
#   endif

#BST := ${addsuffix .bst,${BST_BASENAME}}
#PRESENT_BST := ${filter ${BST},${ALL_BST}}

# ifeq (${words ${DOC}},1)
# TEX_WITH_IND := \
#   ${shell grep --files-with-matches '^ *\\printindex[]' }
# endif

define dvi_data
  if test -r ${1}.log; \
  then \
    data=$$(${SED} --quiet 's|.*\(([0-9].*)\)\.|\1|p' ${1}.log); \
    if test -n "$$data"; \
    then \
      ${ECHO} " done $$data."; \
    else \
      ${ECHO} $$' FAILED:\n  [W] No pages of output. Is the document empty?';\
    fi; \
  fi
endef

loc_of = ${if ${LOC},${LOC}/}${notdir ${1}}

make_sorted_list = \
  ${SORT} --${1} | ${UNIQ} | ${TR} '\n' ' ' \
| ${SED} --quiet "s|^ *\(.*\) $$|\1|p"

norm_list = \
  $$(${ECHO} $$${1} | ${SED} --quiet "s|^ *\(.*\) *$$|\1|p")

head = $$(${ECHO} $$${1} | ${CUT} --fields=1 --delimiter=' ')
tail = $$(${ECHO} $$${1} | ${CUT} --fields=2- --delimiter=' ')

one_id = "\`$$${1}'"
two_id = "\`"$$(${ECHO} $$${1} | ${SED} "s| |' and \`|g")"'"
many_id = "\`"$$(${ECHO} $$${1} | ${SED} "s| |',\`|g")"'"

two_items = $$(${ECHO} $$${1} | ${SED} 's| | and |g')
many_items = $$(${ECHO} $$${1} | ${SED} 's| |,|g')

# ========================================================================
# Figures
#
#EPS := ${notdir ${wildcard *.eps}}
FIG := ${notdir ${wildcard *.fig}}
GIF := ${notdir ${wildcard *.gif}}
JPG := ${notdir ${wildcard *.jpg}}

#EPS_BASE := ${subst .eps,,${EPS}}
FIG_BASE := ${subst .fig,,${FIG}}
GIF_BASE := ${subst .gif,,${GIF}}
JPG_BASE := ${subst .jpg,,${JPG}}
TEX_BASE := ${subst .tex,,${PRESENT_DOC_TEX}}

#   ${strip \
#     ${addsuffix .eps, \
#         ${foreach name,${FIG_BASE},${findstring ${name},${EPS_BASE}}}}}

EPS_FROM_FIG := ${addsuffix .eps, ${FIG_BASE}}
EPS_FROM_GIF := ${addsuffix .eps, ${GIF_BASE}}
EPS_FROM_JPG := ${addsuffix .eps, ${JPG_BASE}}
EPS_FROM_TEX := ${addsuffix .eps, ${TEX_BASE}}
PS_FROM_TEX  := ${addsuffix .ps, ${TEX_BASE}}
PDF_FROM_TEX := ${addsuffix .pdf, ${TEX_BASE}}

# Encapsulated PostScript Bounding boxes
#
BBX := ${notdir ${wildcard *.bbx}}

${subst .bbx,.ps,${BBX}}: %.ps: %.bbx
${subst .bbx,.eps,${BBX}}: %.eps: %.bbx 

# ========================================================================
# Encapsulated PostScript from Xfig format
#
%.fig: ;

ifneq (${FIG2DEV},none)
${EPS_FROM_FIG}: %.eps: %.fig
	${ECHO} -n "Making ${call loc_of,$@} from ${call loc_of,$<} using fig2dev..."
	msg=$$(${strip ${FIG2DEV} -L eps $< $@ 2>&1}); \
        if test -z "$$msg"; \
        then \
          ${ECHO} " done."; \
        else \
          ${ECHO} " FAILED:"; \
          ${ECHO} $$msg; \
        fi
endif

# ========================================================================
# Encapsulated PostScript figures from GIF
#
%.gif: ;

ifneq (${CONVERT},none)
${EPS_FROM_GIF}: %.eps: %.gif
	${ECHO} -n "Making ${call loc_of,$@} from ${call loc_of,$<} using convert..."
	convert_cmd="${strip ${CONVERT} $< $@ 2>&1}"; \
        ${if ${VERB},${ECHO};${ECHO} -n "Calling $$convert_cmd";} \
        err=$$(eval $$convert_cmd); \
        if test -z "$$err"; \
        then \
          ${ECHO} " done."; \
        else \
          ${ECHO} " FAILED:"; \
          ${ECHO} $$err; \
        fi
endif

# ========================================================================
# Encapsulated PostScript figures from JPEG
#
%.jpg: ;

ifneq (${JPEG2EPS},none)
${EPS_FROM_JPG}: %.eps: %.jpg
	${ECHO} -n "Making ${call loc_of,$@} from ${call loc_of,$<} using jpeg2eps..."
	jpeg2eps_cmd="${strip ${JPEG2EPS} $< 2>&1}"; \
        ${if ${VERB},${ECHO};${ECHO} "Calling $$jpeg2eps_cmd";} \
        err=$$(eval $$jpeg2eps_cmd); \
        if test -z "$$err"; \
        then \
          ${ECHO} " done."; \
        else \
          ${ECHO} " FAILED:"; \
          ${ECHO} $$err; \
        fi
endif

# ========================================================================
# Included graphics
#
included_graphics = \
  ${SED} --quiet \
    's|^[^%]*\\includegraphics[*]\?\(\[.*\]\)\?[{]\([-_.[:alnum:]]\+\)[}].*|\2|p' \
    ${1} 2> /dev/null

normalise_graphics = \
  norm_graphics=; \
  for graphics in ${1}; do \
    case $$graphics in \
      *.eps|*.ps) norm_graphics="$$norm_graphics $$graphics";; \
      *) norm_graphics="$$norm_graphics $$graphics.ps";; \
    esac; \
  done; \
  norm_graphics=${call sort_string,$${norm_graphics}}

input_tex = \
  ${strip \
     ${SED} --quiet \
         's|^[^%]*\\\(verbatim\)\?input[{]\([-_.[:alnum:]]\+\)[}].*|\2|p' \
         ${1} 2> /dev/null}

# I hardwired \xinclude
#
included_tex = \
  ${strip \
     ${SED} --quiet \
         's|^[^%]*\\x\?include[{]\([-_.[:alnum:]]\+\)[}].*|\1|p' \
         ${1} 2> /dev/null}

normalise_tex = \
  norm_tex=; \
  for tex_file in ${1}; do \
    case $$tex_file in \
      *.*) norm_tex="$$norm_tex $$tex_file";; \
      *) norm_tex="$$norm_tex $$tex_file.tex";; \
    esac; \
  done; \
  norm_tex=$$(${ECHO} $$norm_tex | ${TR} --squeeze-repeats ' ')

SET_graphics = \
  graphics=; \
  function collect_graphics () { \
    if (  ${ECHO} $$visited_files \
        | grep --word-regexp --invert-match $${1} > /dev/null 2>&1); \
    then \
      visited_files="$$visited_files $${1}"; \
      local input_tex=$$(${call input_tex,$${1}}); \
      local included_tex=$$(${call included_tex,$${1}}); \
      ${call normalise_tex,$${input_tex} $${included_tex}}; \
      local included_graphics=$$(${call included_graphics,$${1}}); \
      graphics="$$graphics $$included_graphics"; \
      if test -n "$$norm_tex"; \
      then \
        for tex_file in $$norm_tex; do \
          collect_graphics $$tex_file; \
        done; \
      fi; \
    fi; \
  }; \
  collect_graphics ${1}

.PHONY: graphics
graphics:
ifeq (${DOC},)
	visited_files=; \
        for tex_document in ${PRESENT_DOC_TEX}; do \
          ${ECHO} ">>> Analysing master document $$tex_document <<<"; \
          ${call SET_graphics,$${tex_document}}; \
          ${call normalise_graphics,$${graphics}}; \
          ${ECHO} "Included graphics are $$norm_graphics"; \
        done
else
	${ECHO} ">>> Analysing master document ${DOC}.tex <<<"
	visited_files=; \
        ${call SET_graphics,${DOC}.tex}; \
        ${call normalise_graphics,$${graphics}}; \
	${ECHO} "Included graphics are $$norm_graphics"
endif

# ========================================================================
# Updating and including bibliographics dependences
# MUST BE BEFORE SECTION ABOUT general dependences (the %.dep must
# be updated before the %.biblio since the latter depends on the
# former, and the order of `sinclude' clauses matters: the last is updated
# first).
#
update_biblio = \
  empty_bib=$$(grep --files-with-matches \
                    '^ *\\bibliography[{] *[}].*' ${1}.tex 2> /dev/null);\
  if test -n "$$empty_bib"; \
  then \
    case ${call num_of,empty_bib} in \
      1) ${ECHO} "  [W] Empty \\bibliography call in $$empty_bib:";; \
      *) ${ECHO} "  [W] Empty \\bibliography calls in ${call many_items,empty_bib}:";; \
    esac; \
    ${ECHO} "      => Add at least an argument to \\bibliography."; \
  else \
    master=$$(${CAT} ${call pref_depdir,${1}.dep} \
              | ${SED} 's|^\(.*\).dvi0 .*${1}\.tex.*|\1|g'); \
    t=$$(grep --with-filename '^ *\\bibliography[{][^{%} ]\+[}].*' ${1}.tex); \
    if test -n "$$t"; \
    then \
      ${ECHO} "$$t" \
    | ${SED} --quiet \
       's|^\(.*\)\.tex:\\bibliography[{]\([^{%} ]\+\)[}].*|\1.bbl: \2|p' \
    | ${TR} --delete ' ' \
    | ${TR} ',' ' ' \
    | ${SED} 's|$$|.bib|g;s| |.bib |g;s|\(.*\)\.bbl:|\1.bbl: \1.dvi0 |g' \
    | ${PERL} -pe 's|\n|\nifeq (\$${FAKE},no)\n	\$${call make_bbl,\$${\@:.bbl=}}\nelse\n	if test ! -s .errors; \\\n	then \\\n	  \$${if \$${DEBUG},echo "[DBG C] Touching .out-of-date in \$${@}: \$$^";} \\\n	  touch .out-of-date; \\\n	fi\nendif\n|g' >| ${call pref_depdir,${1}.biblio}; \
    else \
      ${CAT} < /dev/null >| ${call pref_depdir,${1}.biblio}; \
    fi; \
  fi; \
  ${if ${DEBUG}, \
       if test -z "$$empty_bib" -a -z "$$t"; \
       then \
         touch ${call pref_depdir,${1}.biblio}; \
         ${ECHO} " done (empty)."; \
        else \
          ${ECHO} " done."; \
        fi}

.PRECIOUS: ${call depdir_qualif,%.biblio}

${BIBLIO}: %.biblio: ${call pref_depdir,%.biblio}

${call pref_depdir,%.biblio}: ${call pref_depdir,%.dep}
	${ensure_DEPDIR}
  ifeq (${DEBUG},yes)
	if test -e "$^"; \
        then \
          ${ECHO} -n "Making $@ from $^..."; \
        else \
          ${ECHO} -n "Making $@ from scratch..."; \
        fi
  endif
	${call update_biblio,${notdir $*}}

.PHONY: biblio

biblio: ${BIBLIO}

ifeq (${INCL_BIBLIO},yes)
  ifeq (${DEBUG},yes)
    ${warning >>> Including ${BIBLIO} <<<}
  endif
  sinclude ${call pref_depdir,${BIBLIO}}
endif

# ========================================================================
# Updating and including dependences
#

# File List
#
# Note: TeX cuts log lines without taking into account any
# hyphenation, hence some file may be just unduely cut words at the
# end of the previous line. We bet this is not a problem in practice,
# since we filter the files present in the source directory (it is
# unlikely that the wrong cut creates a real file name, but it could
# be).
#
over_approx_used_files = \
    visited_files=; \
    ${call SET_graphics,${1}.tex}; \
    ${call normalise_graphics,$$graphics}; \
    locally_used_files=$$(${ECHO} "$$visited_files $$norm_graphics" \
                          | ${TR} '\n' ' ' \
                          | ${TR} --squeeze-repeats ' ')

SET_locally_used_files = \
  if test -e ${1}.log -a -e ${1}.aux; \
  then \
    starting_line=$$(grep --line-number '*File List*' ${1}.log \
                     | ${HEAD} --lines=1 \
                     | ${SED} --quiet 's|^\([0-9]*\):.*|\1|p'); \
    if test -n "$$starting_line"; \
    then \
      total_lines=$$(${WC} --lines ${1}.log | ${AWK} '{ print $$1 }'); \
      remaining_lines=$$(${EXPR} $$total_lines - $$starting_line); \
      log_suffix=$$(${TAIL} --lines=$$remaining_lines ${1}.log); \
      ending_line=$$(grep --line-number \
                        "^ [*][*][*][*][*][*][*][*][*][*][*]$$" ${1}.log \
                     | ${HEAD} --lines=1 \
                     | ${SED} --quiet 's|^\([0-9]*\):.*|\1|p'); \
   file_list_section_length=$$(${EXPR} $$ending_line - $$starting_line - 1);\
      file_list_section=$$(${ECHO} "$$log_suffix" \
                           | ${HEAD} --lines=$$file_list_section_length); \
      used_file_list=$$(${ECHO} "$$file_list_section" \
                        | ${AWK} '{ print $$1 }'); \
      locally_used_files=; \
      used_packages=; \
      for FILE in $$used_file_list; do \
        if test -e $$FILE; \
        then \
          locally_used_files="$$locally_used_files $$FILE"; \
        fi; \
        case $$FILE in \
          *.sty) used_packages="$$used_packages $$FILE";; \
        esac; \
      done; \
      locally_used_files="${1}.tex $$locally_used_files"; \
      locally_used_files=$$(${ECHO} $$locally_used_files \
                            | ${TR} ' ' '\n' \
                            | ${SORT} --dictionary-order \
                            | ${UNIQ} \
                            | ${TR} '\n' ' '\
                            | ${TR} --squeeze-repeats ' '); \
      if test -n "$$used_packages"; \
      then \
        used_packages=$$(${ECHO} $$used_packages \
                         | ${TR} ' ' '\n' \
                         | ${SORT} --dictionary-order \
                         | ${UNIQ} \
                         | ${TR} '\n' ' ' \
                         | ${TR} --squeeze-repeats ' '); \
      fi; \
    else \
      locally_used_files=${1}.tex; \
      used_packages=; \
    fi; \
  else \
    ${call over_approx_used_files,${1}}; \
  fi

ifeq (${INCL_DEP},yes)
  ifeq (${DEBUG},yes)
    ${warning >>> Including ${DEP} <<<}
  endif
  sinclude ${call pref_depdir,${DEP}}
endif

.PRECIOUS: %.log ${call depdir_qualif,%.dep} ${call depdir_qualif,%.pkg}

update_dep = \
  ${call SET_locally_used_files,${1}}; \
  if ${ECHO} $$locally_used_files | grep '\.bbl' > /dev/null; \
  then \
      ${ECHO} "${1}.dvi:: $$locally_used_files" \
    | ${TR} --squeeze-repeats ' ' \
    >| ${call pref_depdir,${1}.dep}; \
    filtered_used_files=$$(${ECHO} $$locally_used_files \
                           | ${SED} 's|[-_[:alnum:]]\+\.bbl||g'); \
      ${ECHO} "${1}.dvi0:: $$filtered_used_files" \
    | ${TR} --squeeze-repeats ' ' \
    >> ${call pref_depdir,${1}.dep}; \
  else \
      ${ECHO} "${1}.dvi0 ${1}.dvi:: $$locally_used_files" \
    | ${TR} --squeeze-repeats ' ' \
    >| ${call pref_depdir,${1}.dep}; \
  fi; \
  if test -n "$$used_packages"; \
  then \
    ${ECHO} $$used_packages >| ${call pref_depdir,${1}.pkg}; \
  else \
    ${CAT} < /dev/null >| ${call pref_depdir,${1}.pkg}; \
  fi

ifeq (${KEEP_DEP},no)
${call depdir_qualif,%.dep}: %.log
	${ensure_DEPDIR}
  ifeq (${DEBUG},yes)
	if test -e "$^"; \
        then \
          ${ECHO} -n "Making $@ from $^..."; \
        else \
          ${ECHO} -n "Making $@ from scratch..."; \
        fi
  endif
	${call update_dep,${notdir $*}}
  ifeq (${DEBUG},yes)
	${ECHO} " done."
  endif
endif

.PHONY: dep
dep:
	make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                                  ${DEP}}"; \
        ${if ${VERB},${ECHO} "[VRB 12] Calling $$make_cmd";} \
        eval $$make_cmd

ifeq (${DEPDIR_EXISTS},yes)
mostlyclean::
	${if ${VERB},${ECHO} -n "Deleting dependences..."}
	${RM} --force --recursive ${DEPDIR}
	${if ${VERB},${ECHO} " done."}
endif

# XXX
.PHONY: files
files:
	for doc in ${PRESENT_DOC}; do \
          ${ECHO} ">>> Analysing master document $$doc.tex <<<"; \
          ${call SET_locally_used_files,$${doc}}; \
          ${ECHO} "Locally used files are $$locally_used_files"; \
        done


# ========================================================================
# Interface with the OCaml makefile (pretty-printing of pieces of
# source code with `ocamlweb').

# Variable MLL contains the ocamllex specifications.
#
ifndef MLL
  MLL := ${notdir ${wildcard *.mll}}
  ifeq (${MLL},*)
    MLL :=#
  endif
endif

# Variable MLY contains the ocamlyacc specifications.
#
ifndef MLY
  MLY := ${notdir ${wildcard *.mly}}
  ifeq (${MLY},*)
    MLY :=#
  endif
endif

# Variable MLI contains the ocaml interfaces.
#
ifndef MLI
   MLI := ${notdir ${wildcard *.mli}}
  ifeq (${MLI},*)
    MLI :=#
  endif
endif

# Variable ML contains the ocaml interfaces.
#
ifndef ML
   ML := ${notdir ${wildcard *.ml}}
  ifeq (${ML},*)
    ML :=#
  endif
endif

OCAML_SRC := ${sort ${MLI} ${ML} ${MLL} ${MLY}}

# ifneq (${OCW},)
#   ifeq (${OCAML_SRC},)
# PRETTY_TEX :=#
# OCW_WARNING := $$'  [W] No OCaml source files to pretty-print.\n      => Do you really need package ocamlweb?'
#   else
# PRETTY_TEX := ${GENDOC}.tex
# OCW_WARNING :=#
#   endif
# else
# PRETTY_TEX :=#
# OCW_WARNING :=#
# endif


ifeq (${OCAMLWEB},none)
${GENDOC}.tex:
	@${ECHO} "\`ocamlweb' is not configured: ignoring."
else
  ifneq (${OCAML_SRC},)
${GENDOC}.tex: ${OCAML_SRC}
	${ECHO} -n "Pretty-printing sources to ${call loc_of,${GENDOC}.tex}..."
	ocamlweb_cmd="${strip ${OCAMLWEB} -o $@ --no-preamble --noweb --no-index $^ 2>&1}"; \
    ${if ${VERB},${ECHO};${ECHO} "[VRB E] Calling $$ocamlweb_cmd";} \
    msg=$$(eval $$ocamlweb_cmd);\
        if test -z "$$msg"; \
        then \
          ${ECHO} " done." ; \
        else \
          if   ${ECHO} "$$msg" | grep "warning:" > /dev/null; \
          then ${ECHO} " done, but note that:"; \
               ${ECHO} "$$msg"; \
          else ${ECHO} " FAILED:"; \
               ${ECHO} "$$msg"; \
          fi; \
        fi
  else
${GENDOC}.tex:
  endif
endif

.PHONY: pretty
pretty: ${GENDOC}.tex

# ------------------------------------------------------------------------
# Overfulls
#
SET_overfull_hbox = \
  overfull_hbox=$$(grep 'Overfull \\hbox' ${1}.log 2> /dev/null \
                   | ${WC} --lines | ${TR} --delete ' ')

SET_overfull_vbox = \
  overfull_vbox=$$(grep 'Overfull \\vbox' ${1}.log 2> /dev/null \
                   | ${WC} --lines | ${TR} --delete ' ')

show_overfull_box = \
  ${call SET_overfull_hbox,${1}}; \
  case $$overfull_hbox in \
   0|"") ;; \
   1) ${ECHO} "  [W] 1 horizontal overfull.";; \
   *) ${ECHO} "  [W] $$overfull_hbox horizontal overfulls.";; \
  esac; \
  ${call SET_overfull_vbox,${1}}; \
  case $$overfull_vbox in \
    0|"") ;; \
    1) ${ECHO} "  [W] 1 vertical overfull.";; \
    *) ${ECHO} "  [W] $$overfull_vbox vertical overfulls.";; \
  esac

show_overfulls = \
  ${call show_overfull_box,${1}}; \
  doc_class=$$(${SED} --quiet \
               's|^ *\\documentclass\(\[\(.*\)\]\)\?[{]\(.*\)[}]|\3|p' \
               $*.tex 2> /dev/null); \
  if test "$$doc_class" = "seminar"; \
  then \
    slide_overfulls=$$(${SED} --quiet 's|LaTeX Warning: Slide \(.*\) overfull .*|\1|p' ${1}.log | ${call make_sorted_list,numeric-sort}); \
    if test "$$slide_overfulls" != ""; \
    then \
      if test "$$overfull_hbox" != "0" -o "$$overfull_vbox" != "0"; \
      then \
        ${ECHO} "      The following warning may be partly redundant:"; \
      fi; \
      case ${call num_of,slide_overfulls} in \
        1) ${ECHO} "  [W] Overfull at slide $$slide_overfulls.";; \
        2) ${ECHO} "  [W] Overfull at slides" ${call two_items,slide_overfulls}".";; \
        *) ${ECHO} "  [W] Overfulls at slides" ${call many_items,slide_overfulls}".";; \
      esac; \
    fi; \
  fi

# ------------------------------------------------------------------------
# Underfulls
#
SET_underfull_hbox = \
  underfull_hbox=$$(grep 'Underfull \\hbox' ${1}.log 2> /dev/null \
                   | ${WC} --lines | ${TR} --delete ' ')

SET_underfull_vbox = \
  underfull_vbox=$$(grep 'Underfull \\vbox' ${1}.log 2> /dev/null \
                   | ${WC} --lines | ${TR} --delete ' ')

show_underfulls = \
  ${call SET_underfull_hbox,${1}}; \
  case $$underfull_hbox in \
    0|"") ;; \
    1) ${ECHO} "  [W] 1 horizontal underfull.";; \
    *) ${ECHO} "  [W] $$underfull_hbox horizontal underfulls.";; \
  esac; \
  ${call SET_underfull_vbox,${1}}; \
  case $$underfull_vbox in \
    0|"") ;; \
    1) ${ECHO} "  [W] 1 vertical underfull.";; \
    *) ${ECHO} "  [W] $$underfull_vbox vertical underfulls.";; \
  esac

show_under_overfulls = \
  ${call show_overfulls,${1}}; \
  ${call show_underfulls,${1}}; \
  if test "$$underfull_hbox" != "0" -o "$$underfull_vbox" != "0" \
        -o "$$overfull_hbox" != "0" -o "$$overfull_vbox" != "0" \
        -o "$$slide_overfulls" != ""; \
  then \
    ${ECHO} "      => Rerun make for details or check ${call loc_of,${1}.log} for transcript."; \
  fi

# ------------------------------------------------------------------------
# Get file name
#
SUFFIXES := ${shell \
  suffixes="cls clo tex"; \
  for f in $$(ls); do \
    new_suf=$$(${ECHO} $$f | ${SED} -n 's|.*\.\([^\.]*\)$$|\1|p'); \
    suffixes="$$suffixes $$new_suf"; \
  done; \
  ${ECHO} $$suffixes | ${TR} --complement --delete '[:alnum:] ' \
                  | ${TR} ' ' '\n' | ${SORT} --dictionary-order | ${UNIQ}}

ifeq (${words ${PRESENT_TEX}},1)
SET_file = \
  file=${PRESENT_TEX}
else
SET_file = \
  e=; \
  for s in ${SUFFIXES}; do \
    case "$$s" in \
      ac|aux|cache|dvi|dvi0|status|in|log|log1|bib|blg);; \
      *~|*\#);; \
      *) e="$$e;s|\.$$s|\.$$s |g";; \
    esac \
  done; \
  current=$$(${HEAD} --lines=$$cutting_line_in_log ${1} \
             | ${SED} --expression="$$e" \
             | ${TR} --delete '\n' \
             | ${PERL} -pe 's|\(|\n\(|g;s|\)|\n\)\n|g' \
             | ${TR} ' ' '\n' \
             | grep "([[:alnum:]\|/\|\.]\|)" \
             | ${TR} --delete '\n'); \
  next=$$(${ECHO} $$current | ${PERL} -pe 's|\(|\n\(|g;s|\)|\)\n|g' \
          | grep --invert-match "(.*)" | ${TR} --delete '\n'); \
  until test "$$current" = "$$next"; do \
    tmp=$$current; \
    current=$$next; \
    next=$$(${ECHO} $$current | ${PERL} -pe 's|\(|\n\(|g;s|\)|\)\n|g' \
            | grep --invert-match "(.*)" | ${TR} --delete '\n'); \
  done; \
  file=$$(${ECHO} $$current | ${TR} --delete ')' \
          | ${SED} 's=.*(\([^(]\+\)$$=\1=g'); \
  if test -n "$$file"; \
  then \
    dirname_of_file=$$(dirname $$file); \
    if test "$$dirname_of_file" = "."; \
    then \
      file=$$(basename $$file); \
    fi; \
  fi
endif

# ------------------------------------------------------------------------
# Errors
#
SET_latex_error = \
  latex_error=$$(${SED} --quiet "s|^! \(.*\)|\1|p" ${1} 2> /dev/null \
                 | ${HEAD} --lines=1)

# make_next = \
#   $$(${ECHO} $$current | ${PERL} -pe 's|\(|\n\(|g;s|\)|\)\n|g' \
#      | grep --invert-match "(.*)" \
#      | ${TR} --delete '\n')

find_latex_error = \
  ${call SET_latex_error,${1}.${2}}; \
  if test -n "$$latex_error"; \
  then \
    line=$$(${SED} --quiet "s|^l\.\([0-9]\+\).*|\1|p" ${1}.${2} \
            | ${TR} '\n' ' ' \
            | ${CUT} --fields=1 --delimiter=' '); \
    linenum_in_log=$$(grep --line-number '^! .*' ${1}.${2} \
                      | ${HEAD} --lines=1 \
                      | ${SED} --quiet 's|^\([0-9]*\):.*|\1|p'); \
    linenum_in_log=$$(${EXPR} $$linenum_in_log - 1); \
    runaway_line=$$(${NL} --body-numbering=a ${1}.${2} \
                | ${SED} --quiet "s|^ *\([0-9]\+\).*Runaway argument?|\1|p" \
                | ${TR} '\n' ' ' \
                | ${CUT} --fields=1 --delimiter=' '); \
    if test -n "$$runaway_line"; \
    then \
      cutting_line_in_log=$$runaway_line; \
    else \
      cutting_line_in_log=$$linenum_in_log; \
    fi; \
    ${call SET_file,${1}.${2}}; \
    if test -z "$$file" -o ! -e "$$file"; \
    then \
      in_file=; \
    else \
      in_file=" in ${if ${LOC},${LOC}/}$$file"; \
    fi; \
    if test "$$latex_error" = "Undefined control sequence."; \
    then \
      line_after=$$(grep --after-context=1 "^! .*" ${1}.${2} 2> /dev/null \
                    | ${HEAD} --lines=2 \
                    | ${TAIL} --lines=1); \
      error_line=$$(${SED} --quiet 's|^l.[[:digit:]]\+ \(.*\)|\1|p' ${1}.${2} \
                    | ${HEAD} --lines=1); \
      if test "$$line_after" = "$$error_line"; \
      then \
        undefined_macro=$$(${ECHO} $$error_line \
                           | ${SED} --quiet 's|.*\(\\[^ ]\+\)$$|\1|p'); \
      else \
        undefined_macro=$$(${ECHO} $$line_after \
                           | ${SED} --quiet 's|.*\(\\[^ ]\+\)$$|\1|p'); \
      fi; \
      if test -n "$$undefined_macro"; \
      then \
        latex_error="Undefined control sequence $$undefined_macro."; \
      fi; \
    fi; \
    if test -z "$$line"; \
    then \
      if test -z "$$file" -a -z "$$runaway_line"; \
      then \
        ${call signal_error, "  [E] $${latex_error}"}; \
      else \
        ${call signal_error, "  [E] Error$${in_file}:"}; \
        if test -n "$$runaway_line"; \
        then \
         tmp=$$(grep --after-context=1 "^Runaway argument?" ${1}.${2} \
                     2> /dev/null \
                | ${TAIL} --lines=1 \
                | ${SED} --quiet "s|^\(.*\)$$|      \1|p"); \
         ${call signal_error, "$${tmp}"}; \
        fi; \
        ${call signal_error, "      $${latex_error}"}; \
      fi; \
    else \
      ${call signal_error, "  [E] Error$${in_file} at line $${line}:"}; \
      ${call signal_error, "      $${latex_error}"}; \
    fi; \
    linenum_in_log=$$(${EXPR} $$linenum_in_log + 1); \
    ${call signal_error, "      => Check line $${linenum_in_log} in ${1}.log."}; \
    if test -n "$$runaway_line" -a "$$file" != ${1}.tex; \
    then \
      ${call signal_error, "      => Check the included or input file."}; \
    fi; \
  fi

# ------------------------------------------------------------------------
# Making DVI for the first time.
#
SET_filtered_missing_files = \
  missing_files=$$(${SED} --quiet 's|^No file \([^ ]\+\)\.|\1|p' ${2}.log \
                       2> /dev/null); \
  filtered_missing_files=; \
  for file in $$missing_files; do \
    reject=false; \
    for suffix in ${1}; do \
      without_suffix=$$(basename $$file .$$suffix); \
      if test "$$file" != "$$without_suffix"; \
      then \
        reject=true; \
        break; \
      fi; \
    done; \
    if test "$$reject" = "false"; \
    then \
      filtered_missing_files="$$filtered_missing_files $$file"; \
    fi; \
  done

no_file_warning = \
  ${call SET_filtered_missing_files,aux lof bbl toc ind,${1}}; \
  case ${call num_of,filtered_missing_files} in \
    0|"");; \
    1) ${ECHO} "  [W] Missing file$$filtered_missing_files."; \
       ${ECHO} "      => Check the included or input file name.";; \
    2) ${ECHO} "  [W] Missing files ${call two_items,filtered_missing_files}."; \
       ${ECHO} "      => Check the included or input file names.";; \
    *) ${ECHO} "  [W] Missing files ${call many_items,filtered_missing_files}."; \
       ${ECHO} "      => Check the included or input file names.";; \
  esac

record_latex_success = \
  if test -e .errors; \
  then \
    err=$$(${CAT} .errors); \
    ${RM} --force .errors; \
    for tex_basename in $$err; do \
      if test "$$tex_basename" != "${1}"; \
      then \
        ${if ${DEBUG},${ECHO} "[DBG 11] Adding \`$${tex_basename}' to .errors";} \
        ${ECHO} $$tex_basename >> .errors; \
      fi; \
    done; \
  fi

record_latex_failure = \
  if ! (grep ${1} .errors > /dev/null 2>&1); \
  then \
    ${if ${DEBUG},${ECHO} "[DBG 10] Adding \`${1}' to .errors";} \
    ${ECHO} ${1} >> .errors; \
  fi; \
  if ! (grep ${1} .errmsg > /dev/null 2>&1); \
  then \
    ${if ${DEBUG},${ECHO} "[DBG E] Adding \`${1}' to .errmsg";} \
    ${ECHO} ${1} >> .errmsg; \
  fi

latex_failure = \
  ${ECHO} " FAILED:"; \
  ${call find_latex_error,${1},log}; \
  if test -n "$$latex_error"; \
  then \
    ${call record_latex_failure,${1}}; \
  fi; \
  if test ! -e "$$file"; \
  then \
    if grep rfull ${1}.log > /dev/null 2>&1; \
    then \
      if test "${words ${PRESENT_TEX}}" != "1"; \
      then \
        ${ECHO} "      => Rerun make to try to get the erroneous file name."; \
      fi; \
    fi; \
  fi; \
  ${call over_approx_used_files,${1}}

latex = \
  latex_cmd='${strip ${LATEX} ${LATEX_OPT} ${PROLOGUE} ${1}.tex > /dev/null 2>&1}'; \
  ${if ${VERB}, ${ECHO}; ${ECHO} "[VRB 17] Calling $$latex_cmd";} \
  $$(eval $$latex_cmd); \
  if test "$$?" = "0"; \
  then \
    ${call record_time_stamp,${1}.dvi}; \
    ${call dvi_data,${1}}; \
    make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                              ${1}.dep \
                              DOC:=${1} \
                              INCL_DEP:=no \
                              INCL_BIBLIO:=no}"; \
    ${if ${VERB},${ECHO} "[VRB 11] Calling $$make_cmd";} \
    eval $$make_cmd; \
    latex_status=passed; \
  else \
    ${call latex_failure,${1}}; \
    latex_status=failed; \
  fi

# Removed  ${if ${OCW_WARNING}, ${ECHO} ${OCW_WARNING};}
#
make_dvi0 = \
  ${if ${DEBUG},${ECHO} "[DBG 9] Entering make_dvi0 with \$${1}=${1}";} \
  ${ECHO} -n "Making ${call loc_of,${1}.dvi} from ${call loc_of,${1}.tex}..."; \
  ${call latex,${1}}; \
  if test "$$latex_status" = "passed"; \
  then \
    ${if ${TOC_WARNING}, ${ECHO} ${TOC_WARNING};} \
    ${call no_file_warning,${1}}; \
    ${call record_latex_success,${1}}; \
  fi; \
  if test -e ${1}.dvi; \
  then \
    ${MV} --force ${1}.dvi{,0}; \
  fi

%.dvi0::
ifeq (${LATEX},none)
	@${ECHO} "LaTeX is not configured."
else 
  ifeq (${FAKE},no)
	${call make_dvi0,$*}
  endif
endif

ifneq (${DOC},)
mostlyclean::
	if test -f . ${DOC:%=-o -e %.dvi0}; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting DVI0 files...";} \
          ${RM} --force ${DOC:%=%.dvi0}; \
          ${if ${VERB},${ECHO} " done.";} \
        fi
endif

# ------------------------------------------------------------------------
# Multiple labels
#
PRINT_multiple_labels = \
  case ${call num_of,multiple_labels} in \
    0|"") ;; \
    1) ${ECHO} "  [W] Multiply-defined label" \
            ${call one_id,multiple_labels}"."; \
       ${ECHO} "      => Check spellings or rename or remove all but one occurrence.";; \
    2) ${ECHO} "  [W] Multiply-defined labels" \
            ${call two_id,multiple_labels}"."; \
       ${ECHO} "      => Check spellings or rename or remove all but one occurrence.";; \
    *) ${ECHO} "  [W] Multiply-defined labels" \
            ${call many_id,multiple_labels}"."; \
       ${ECHO} "      => Check spellings or rename or remove all but one occurrence.";; \
  esac


# ------------------------------------------------------------------------
# Citations
#
# In case of a \cite{X} in a `.tex' file, which is undefined, we will
# report it immediately after running `bibtex'. In case the citation
# is in the `.bib', we can only report it after running `latex' to
# solve the citations. Hence, in the first case, we don't want to
# report two times the undefined citation. Moreover we assume that a
# citation can occur _only_ inside a `.tex' or `.bib' file.
#
ifeq (${ALL_BIB},)
advice = \
  if test -z "${3}"; \
  then \
    ${ECHO} "      => Create a bibliography and call \\bibliography in ${call loc_of,${2}.tex}."; \
  else \
  case ${1} in \
    1) ${ECHO} "      => Check spelling or add corresponding entry.";; \
    *) ${ECHO} "      => Check spellings or add corresponding entries.";; \
  esac; \
  fi
else
advice = \
  if test -z "${3}"; \
  then \
    ${ECHO} "      => Create a bibliography and/or call \\bibliography in ${call loc_of,${2}.tex}."; \
  else \
    case ${1} in \
      1) ${ECHO} "      => Check spelling, add entry or add an argument to \\bibliography.";; \
      *) ${ECHO} "      => Check spellings, add entries or add arguments to \\bibliography.";; \
    esac; \
  fi
endif

PRINT_undef_cit = \
  ${call SET_slave_bib,${2}}; \
  case ${call num_of,${1}} in \
    0|"") ;; \
    1) ${ECHO} "  [W] Undefined citation" ${call one_id,${1}}"."; \
       ${call advice,1,${2},$${slave_bib}};; \
    2) ${ECHO} "  [W] Undefined citations" ${call two_id,${1}}"."; \
       ${call advice,2,${2},$${slave_bib}};; \
    *) ${ECHO} "  [W] Undefined citations:" ${call many_id,${1}}"."; \
       ${call advice,many,${2},$${slave_bib}};; \
  esac; \
  case ${call num_of,${1}} in \
    0|"") ;; \
    *) ${call SET_slave_tex,${2}}; \
       if test -n "$$slave_tex" -o -n "$$slave_bib"; \
       then \
         for file in $$slave_tex $$slave_bib; do \
           citations=; \
           for citation in $$${1}; do \
             if grep "\\\cite\(\[.*\]\)\?[{].*,\?$$citation,\?.*[}]" \
                     $$file > /dev/null 2>&1; \
             then \
               citations="$$citations $$citation"; \
             fi; \
           done; \
           citations=${call norm_list,citations}; \
           case ${call num_of,citations} in \
             0|"") ;; \
             1) ${ECHO} "         *" ${call many_items,file} \
                     "cites" ${call one_id,citations}".";; \
             2) ${ECHO} "         *" ${call many_items,file} \
                     "cite" ${call two_id,citations}".";; \
             *) ${ECHO} "         *" ${call many_items,file} \
                     "cite" ${call many_id,citations}".";; \
           esac; \
         done; \
       fi;; \
  esac


# ------------------------------------------------------------------------
# Warnings and errors in bibliographies
#
SET_warnings_in_blg = \
  warnings_in_blg=$$(${SED} --quiet 's|^Warning--\(.*\)|\1|p' ${1:%=%.blg} \
                       2> /dev/null)

SET_generic_warnings_in_blg = \
  if test -n "$$warnings_in_blg"; \
  then \
    generic_warnings_in_blg=$$(${ECHO} "$$warnings_in_blg" \
      | grep --invert-match \
         --regexp="I didn.t find a database entry for .*" 2> /dev/null); \
  fi

PRINT_generic_warnings_in_blg = \
  if test -n "$$generic_warnings_in_blg"; \
  then \
      ${ECHO} "$$generic_warnings_in_blg" \
    | while read warning; do \
        entry=$$(${ECHO} $$warning | ${SED} --quiet 's|.* in \(.*\)|\1|p' \
                                  2> /dev/null); \
        if test -n "$$entry"; \
        then \
          bibs_with_entry=$$(grep --files-with-matches "{$$entry," \
                                  $$bib 2> /dev/null);\
          case ${call num_of,bibs_with_entry} in \
            0|"") ${ECHO} "  [W] $$warning.";; \
            1) case $$(${ECHO} $$bib | ${WC} --words | ${TR} --delete ' ') in \
                 0|"");; \
                 1) ${ECHO} "  [W] $$warning.";; \
                 *) ${ECHO} "  [W] $$warning of $$bibs_with_entry.";; \
               esac;; \
            2) ${ECHO} "  [W] $$warning of ${call two_items,bibs_with_entry}.";; \
            *) ${ECHO} "  [W] $$warning of ${call many_items,bibs_with_entry}.";; \
          esac; \
        else \
          ${ECHO} "  [W] $$warning."; \
        fi; \
      done; \
  fi

SET_missing_entries = \
  if test -n "$$warnings_in_blg"; \
  then \
    missing_entries=$$(${ECHO} "$$warnings_in_blg" \
    | ${SED} --quiet 's|I didn.t find a database entry for "\(.*\)"|\1|p' \
          2> /dev/null \
    | ${call make_sorted_list,dictionary-order}); \
  fi

SET_num_errors = \
  num_errors=$$(${SED} --quiet 's=.*\(was\|were\) \(.*\) error.*=\2=p' \
                            $$blg 2> /dev/null)

errors_in_blg = \
  case ${1} in \
    0|"") ;; \
    *) if grep 'I found no \\bibstyle command' $$blg > /dev/null 2>&1; \
       then \
         ${call signal_error, "  [E] \\bibliographystyle is missing:"}; \
         ${call signal_error, "      => Choose a style and add a call."}; \
       fi; \
       if grep 'I found no \\citation commands' $$blg  > /dev/null 2>&1; \
       then \
         ${call signal_error, "  [E] \\cite calls are missing:"}; \
         ${call signal_error, "      => Add citations or use \\nocite."}; \
       fi; \
       missing_bst=$$(${SED} --quiet \
         "s|I couldn't open style file \(.*\)|\1|p" $$blg); \
       if test "$$missing_bst" != ""; \
       then \
         ${call signal_error, "  [E] Bibliography style file ${if ${LOC},${LOC}/}$${missing_bst} is missing."}; \
         ${call signal_error, "      (This error is counted two times.)"}; \
         ${call signal_error, "      => Check spelling or make this file available."}; \
       fi; \
       all_errors=$$(grep --regexp="^[[:alpha:]][^-]*---line .*" $$blg 2> /dev/null); \
       for b in ${BIB_BASENAMES}; do \
         repeated=$$(${ECHO} "$$all_errors" \
           | ${SED} --quiet \
               "s|Repeated entry---line \(.*\) of file $$b.bib|\1|p" $$blg \
           | ${call make_sorted_list,numeric-sort}); \
         repeated_entries=; \
           for line in $$repeated; do \
             repeated_entry=$$(${NL} --body-numbering=a $$b.bib \
               | ${SED} --quiet "s|^ *$$line[^0-9].*@.*[{]\(.*\),.*|\1|p"); \
              repeated_entries="$$repeated_entries"$$'\n'"$$repeated_entry"; \
           done; \
         repeated_entries=$$(${ECHO} "$$repeated_entries" \
                             | ${call make_sorted_list,dictionary-order}); \
         case ${call num_of,repeated_entries} in \
           0|"") ;; \
           1) aux=${call one_id,repeated_entries}; \
              ${call signal_error, "  [E] Repeated entry $${aux}"};; \
           2) aux=${call two_id,repeated_entries}; \
              ${call signal_error, "  [E] Repeated entries $${aux}"};; \
           *) aux=${call many_id,repeated_entries}; \
              ${call signal_error, "  [E] Repeated entries: $${aux}"};; \
         esac; \
         case ${call num_of,repeated} in \
           0|"") ;; \
           1) ${call signal_error, " in ${if ${LOC},${LOC}/}$${b}.bib at line $$repeated."}; \
              ${call signal_error, "      => Merge entries or rename or remove the redundant one."};; \
           2) ${call signal_error, "      in ${if ${LOC},${LOC}/}$${b}.bib at lines ${call two_items,repeated}."}; \
              ${call signal_error, "      => Merge entries or rename or remove the redundant one."};; \
           *) ${call signal_error, "      in ${if ${LOC},${LOC}/}$${b}.bib at lines ${call many_items,repeated}."}; \
              ${call signal_error, "      => Merge entries or rename or remove the redundant one."};; \
         esac; \
       done; \
       other_errors=$$(${ECHO} "$$all_errors" \
         | grep --invert-match --regexp="^Repeated entry---line .*" \
                2> /dev/null); \
       if test -n "$$other_errors"; \
       then \
           ${ECHO} "$$other_errors" \
         | while read err; do \
              msg=$$(${ECHO} $$err \
                     | ${SED} "s=^\(.*\)---line \([0-9]\+\) \(of file \([[:alnum:]\|_\|\.]\+\)\)\?.*=  [E] \1 at line \2 in file \4.=g" \
                           2> /dev/null); \
              ${call signal_error, "$${msg}"}; \
           done; \
       else \
         two_lines_errors=$$(grep --before-context=1 "^[-][-][-]line" $$blg \
                             | ${SED} 's|^--$$||g'); \
         if test -n "$$two_lines_errors"; \
         then \
             skip_iter=no; \
             ${ECHO} "$$two_lines_errors" \
           | while read err; do \
               if test $$skip_iter = no; \
               then \
                 if test -n "$$err"; \
                 then \
                   aux=$$(${EXPR} match "$$err" "I couldn't open style file \(.*\)"); \
                   if test -z "$$aux"; \
                   then \
                     skip_iter=no; \
                     msg=$$(${ECHO} "$$err" \
                            | ${SED} --quiet "s|^\([^-].*\)|  [E] \1|p"); \
                     if test -n "$$msg"; \
                     then \
                       ${call signal_error, "$${msg}"}; \
                     else \
                       msg=$$(${ECHO} "$$err" \
                              | ${SED} --quiet "s%^---line \([0-9]\+\) \(of file \([[:alnum:]\|_\|\.]\+\)\)\?.*%      => Check line \1 in file \3.%p" \
                                    2> /dev/null); \
                       if test -n "$$msg"; \
                       then \
                         ${call signal_error, "$${msg}"}; \
                       fi; \
                     fi; \
                   else \
                     skip_iter=yes; \
                   fi; \
                 fi; \
               else \
                 skip_iter=no; \
               fi; \
             done; \
         fi; \
       fi;; \
  esac        


# ------------------------------------------------------------------------
# Making bibliographies
#

# Minimum cross-references
#
MCR :=2#

ifeq (${BIBTEX},none)
make_bbl = \
  @${ECHO} "BibTeX is not configured; skipping bibliography."
else
make_bbl = \
  ${call SET_latex_error,${1}.log}; \
  if test -z "$$latex_error"; \
  then \
    bib=$$(${SED} --quiet 's|^ *\\bibliography[{]\([^{%} ]\+\)[}].*|\1|p' \
                       ${1}.tex \
           | ${TR} --delete ' ' \
           | ${SED} 's|,|.bib |g;s|$$|.bib|g'); \
    case ${call num_of,bib} in \
      1) ${ECHO} -n "Processing bibliography $$bib of ${1}.tex...";; \
      2) ${ECHO} -n "Processing bibliographies" \
                 $$(${ECHO} $$bib | ${SED} 's| | and |g') \
                 "of ${1}.tex...";; \
      *) ${ECHO} -n "Processing bibliographies" \
                 $$(${ECHO} $$bib | ${SED} 's| |,|g') \
                 "of ${1}.tex...";; \
    esac; \
    ${BIBTEX} -terse -min-crossrefs=${MCR} ${1} > /dev/null; \
    ${ECHO} -n " done"; \
    touch .ran-bibtex; \
    entries=$$(${SED} --quiet \
                   's/.*used \(.*\) \(entries\|entry\).*/\1/p' \
                   ${1}.blg 2> /dev/null); \
    case $$entries in \
       "") ${ECHO} -n " (0 entry";; \
      0|1) ${ECHO} -n " ($$entries entry";; \
        *) ${ECHO} -n " ($$entries entries";; \
    esac; \
    blg=${1}.blg; \
    ${SET_num_errors}; \
    case $$num_errors in \
      0|"") ;; \
      1) ${ECHO} -n ", 1 error";; \
      *) ${ECHO} -n ", $$num_errors errors";; \
    esac; \
    num_warnings=$$(grep --count Warning ${1}.blg 2> /dev/null); \
    case $$num_warnings in \
      0|"") if test "$$num_errors" = "0" -o -z "$$num_errors"; \
            then ${ECHO} ")."; \
            else ${ECHO} "):"; \
            fi;; \
      1) ${ECHO} ", 1 warning):";; \
      *) ${ECHO} ", $$num_warnings warnings):";; \
    esac; \
    ${call errors_in_blg,$${num_errors}}; \
    ${call SET_warnings_in_blg,${1}}; \
    ${SET_missing_entries}; \
    ${call PRINT_undef_cit,missing_entries,${1}}; \
    ${SET_generic_warnings_in_blg}; \
    ${PRINT_generic_warnings_in_blg}; \
  fi
endif

ifneq (${BBL},)
override DEL_BBL := ${BBL}
mostlyclean::
	if test -f . ${DEL_BBL:%=-o -e %}; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting compiled bibliographies...";} \
          ${RM} --force ${DEL_BBL}; \
          ${if ${VERB},${ECHO} " done.";} \
        fi
endif

ifneq (${BLG},)
override DEL_BLG := ${BLG}
mostlyclean::
	if test -f . ${DEL_BLG:%=-o -e %}; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting bibliography logs...";} \
          ${RM} --force ${DEL_BLG}; \
          ${if ${VERB},${ECHO} " done.";} \
        fi
endif

# ------------------------------------------------------------------------
# Indexes

MAKEINDEX := @MAKEINDEX@

ALL_IST := ${notdir ${wildcard *.ist}}
IST :=#
ifneq (${words ${ALL_IST}},0)
  ifeq (${words ${ALL_IST}},1)
    IST := ${ALL_IST}
  else
    ${warning There is more than one index style file (${ALL_IST}).}
    ${error Remove some of them or distinguish one with IST.}
  endif
endif

ifneq (${MAKECMDGOALS},clean)
  ifneq (${MAKECMDGOALS},distclean)
Makefile.ind: ${PRESENT_TEX}
  endif
endif

#ind: ${IND}

%.ind: %.idx ${if ${IST},${IST}}

# ------------------------------------------------------------------------
# Labels and references
#
# 
PRINT_undefined_ref = \
  case ${call num_of,undefined_ref} in \
    0|"") ;; \
    1) ${ECHO} "  [W] Undefined reference" \
            ${call one_id,undefined_ref}"."; \
       ${ECHO} "      => Check spelling or add corresponding \\label.";; \
    2) ${ECHO} "  [W] Undefined references" \
            ${call two_id,undefined_ref}"."; \
       ${ECHO} "      => Check spellings or add corresponding \\label.";; \
    *) ${ECHO} "  [W] Undefined references:" \
            ${call many_id,undefined_ref}"."; \
       ${ECHO} "      => Check spellings or add corresponding \\label.";; \
  esac; \
  case ${call num_of,undefined_ref} in \
    0|"") ;; \
    *) ${call SET_slave_tex,${1}}; \
       ${call SET_slave_bib,${1}}; \
       for file in $$slave_tex $$slave_bib; do \
         references=; \
         for reference in $$undefined_ref; do \
           if grep "\\\\\(page\)\?ref[{]$$reference[}]" $$file > /dev/null 2>&1; \
           then \
             references="$$references $$reference"; \
           fi; \
         done; \
         references=${call norm_list,references}; \
         if test "${words ${PRESENT_TEX}}" != "1"; \
         then \
           case ${call num_of,references} in \
             0|"") ;; \
             1) ${ECHO} "         *" ${call many_items,file} \
                     "refers to" ${call one_id,references}".";; \
             2) ${ECHO} "         *" ${call many_items,file} \
                     "refers to" ${call two_id,references}".";; \
             *) ${ECHO} "         *" ${call many_items,file} \
                     "refers to:" ${call many_id,references}".";; \
           esac; \
         fi; \
       done;; \
  esac

SET_label_change = \
  label_change=$$(${SED} --quiet \
    "s|LaTeX Warning: Label(s) may have changed. Rerun to get cross-references right.|yes|p" ${1}.log \
    2> /dev/null \
  | ${call make_sorted_list,dictionary-order})

SET_multiple_labels = \
  multiple_labels=$$(${SED} --quiet \
    "s|LaTeX Warning: Label \`\(.*\)' multiply defined.|\1|p" ${1}.log \
    2> /dev/null \
  | ${call make_sorted_list,dictionary-order})

multiple_labels = \
  ${call SET_multiple_labels,${1}}; \
  ${PRINT_multiple_labels}

# Attention: il ne faut pas inclure dans la regexp "input line" car il
# se peut que le mot "input" soit coupe!
#
SET_undefined_ref = \
  undefined_ref=$$(${SED} --quiet \
    "s|LaTeX Warning: Reference \`\([^ ]\+\)' .*|\1|p" ${1}.log \
    2> /dev/null \
  | ${call make_sorted_list,dictionary-order})

undefined_ref = \
  ${call SET_undefined_ref,${1}}; \
  ${call PRINT_undefined_ref,${1}}

# Attention: il ne faut pas inclure dans la regexp "input line" car il
# se peut que le mot "input" soit coupe!
#
SET_undefined_citations = \
  undefined_citations=$$(${SED} --quiet \
    "s|LaTeX Warning: Citation \`\([^ ]\+\)' .*|\1|p" ${1}.log \
    2> /dev/null \
  | ${call make_sorted_list,dictionary-order})

find_all_missing_cit = \
  ${call SET_undefined_citations,${1}}; \
  ${call PRINT_undef_cit,undefined_citations,${1}}

# Removed   blg="${BLG}";
#
find_add_missing_cit = \
  ${call SET_undefined_citations,${1}}; \
  ${call SET_slave_base_blg,${1}}; \
  ${call SET_warnings_in_blg,$${slave_base_blg}}; \
  ${SET_missing_entries}; \
  additional_citations=; \
  remaining_entries=$$missing_entries; \
  for citation in $$undefined_citations; do \
    if test -z "$$remaining_entries"; \
    then \
      additional_citations="$$additional_citations $$citation"; \
    else \
      fst_entry=${call head,remaining_entries}; \
      if test "$$fst_entry" = "$$citation"; \
      then \
        remaining_entries=${call tail,remaining_entries}; \
      else \
        additional_citations="$$additional_citations $$citation"; \
      fi; \
    fi; \
  done; \
  additional_citations=${call norm_list,additional_citations}; \
  ${call PRINT_undef_cit,additional_citations,${1}}

# ------------------------------------------------------------------------
# Detailed report of underfulls and overfulls in .log
#
# This feature is enabled when the document is already
# up-to-date. (Otherwise a summary of the underfulls and overfulls is
# displayed.)
#
SET_page = \
  page=$$(${HEAD} --lines=${2} ${1} 2>/dev/null\
          | ${TR} --delete '\n' | ${TR} --delete ' ' \
          | ${SED} --quiet 's|.*\[\([0-9]\+\)\].*|\1|p' 2>/dev/null); \
  page=$$(${EXPR} $$page + 1 2>/dev/null); \
  if test $$? -ne 0; \
  then \
    page=; \
  fi

hbox_init = \
  linenum_in_log=$$(${ECHO} "$$line" | ${SED} --quiet 's|^\(.*\):.*|\1|p'); \
  prefix=$$(${HEAD} --lines=$$linenum_in_log ${1}.log1); \
  line_in_log=$$(${ECHO} "$$prefix" | ${TAIL} --lines=1); \
  linenum_in_tex=$$(${ECHO} "$$line_in_log" \
                   | ${SED} --quiet 's|.* \(line [0-9]\+\)|\1|p'); \
  if test -z "$$linenum_in_tex"; \
  then \
    linenum_in_tex=$$(${ECHO} "$$line_in_log" \
                   | ${SED} --quiet 's|.* \(lines [0-9]\+--[0-9]\+\)|\1|p');\
  fi

SET_message = \
  file_size=$$(${WC} --lines ${1}.log1 | ${AWK} '{ print $$1 }') ; \
  suffix=$$(${TAIL} --lines=$$(${EXPR} $$file_size - $$linenum_in_log) ${1}.log1); \
  message_size=$$(${ECHO} "$$suffix" \
                  | grep "^ \[\]\$$" --line-number --max-count=1 \
                  | ${SED} 's|\([0-9]\+\):.*|\1|g' \
                 ); \
  message_size=$$(${EXPR} $$message_size - 1); \
  message=$$(${ECHO} "$$suffix" | ${HEAD} --lines=$$message_size); \
  new_suffix_size=$$(${EXPR} $$file_size - $$linenum_in_log - $$message_size); \
  new_suffix=$$(${TAIL} --lines=$$new_suffix_size ${1}.log1); \
  prefix=$$(${HEAD} --lines=$$linenum_in_log ${1}.log1)

clean_message = \
  ${ECHO} "$$prefix" >| ${1}.log1; \
  for ((num=$$message_size;$$num>0;num--)) do \
    ${ECHO} | (${CAT} >> ${1}.log1); \
  done; \
  ${ECHO} "$$new_suffix" >> ${1}.log1

u_vbox = \
  linenum_in_log=$$(${ECHO} "$$line" | ${SED} --quiet 's|^\(.*\):.*|\1|p'); \
  line_in_log=$$(${HEAD} --lines=$$linenum_in_log ${1}.log1 \
                 | ${TAIL} --lines=1); \
  badness=$$(${ECHO} "$$line_in_log" \
            | ${SED} --quiet 's|.*\((badness .*)\).*|\1|p'); \
  ${call SET_page,${1}.log1,$${linenum_in_log}}; \
  cutting_line_in_log=$$linenum_in_log; \
  ${call SET_file,${1}.log1,$${linenum_in_log}}; \
  if test -z "$$file"; \
  then \
    ${ECHO} "  [W] Underfull \\vbox $$badness at page $$page."; \
  else \
    ${ECHO} "  [W] Underfull \\vbox $$badness in $$file."; \
    ${ECHO} "      => Check page $$page."; \
  fi

PRINT_message = \
  filtered=$$(${ECHO} "$$message" \
              | ${TR} --delete '\n' \
              | ${SED} -e 's+\\OT1/[[:alnum:]\|/\|\.]*++g' \
                    -e 's+\\OMS/[[:alnum:]\|/\|\.]*++g' \
                    -e 's+\\OML/[[:alnum:]\|/\|\.]*++g' \
                    -e 's+\\T1/[[:alnum:]\|/\|\.]*++g' \
                    -e 's+\\OMS/[[:alnum:]\|/\|\.]*++g' \
                    -e 's+\\OMX/[[:alnum:]\|/\|\.]*++g' \
                    -e 's+\\U/[[:alnum:]\|/\|\.]*++g' \
                    -e 's+\\OT2/[[:alnum:]\|/\|\.]*++g' \
                    -e 's+\\PD1/[[:alnum:]\|/\|\.]*++g' \
                    -e 's|\[\]||g' \
                    -e 's|$$[^$$]*\$$|<maths>|g' \
                    -e 's|$$[^$$]*$$|<maths>|g' \
                    -e 's|\^^[[:alnum:]]*||g' \
                    -e 's|^ *||g' \
                    -e 's|[ ]\+| |g'); \
  if test -n "$$filtered"; \
  then ${ECHO} $$':\n' "     $$filtered"; \
  else ${ECHO} "."; \
  fi

u_hbox = \
  ${call hbox_init,${1}}; \
  badness=$$(${ECHO} "$$line_in_log" \
             | ${SED} --quiet 's|.*\((badness .*)\).*|\1|p'); \
  ${call SET_page,${1}.log1,$${linenum_in_log}}; \
  cutting_line_in_log=$$linenum_in_log; \
  ${call SET_file,${1}.log1,$${linenum_in_log}}; \
  ${call SET_message,${1},$${linenum_in_log}}; \
  if test -z "$$file"; \
  then \
    ${ECHO} "  [W] Underfull \\hbox $$badness at page $$page."; \
  else \
    if test -z "$$linenum_in_tex"; \
    then \
      ${ECHO} -n "  [W] Underfull \\hbox $$badness in $$file"; \
    else \
      ${ECHO} -n "  [W] Underfull \\hbox $$badness in $$file at $$linenum_in_tex"; \
    fi; \
    ${PRINT_message}; \
    ${ECHO} "      => Check page $$page and line $$linenum_in_log in ${1}.log."; \
  fi; \
  ${call clean_message,${1}}

o_hbox = \
  ${call hbox_init,${1}}; \
  too_wide=$$(${ECHO} "$$line_in_log" \
              | ${SED} --quiet 's|.*(\(.*pt\) too wide).*|\1|p'); \
  ${call SET_page,${1}.log1,$${linenum_in_log}}; \
  cutting_line_in_log=$$linenum_in_log; \
  ${call SET_file,${1}.log1}; \
  ${call SET_message,${1}}; \
  if test -z "$$file"; \
  then \
    ${ECHO} "  [W] Overfull \\hbox ($$too_wide) at page $$page."; \
  else \
    if test -z "$$linenum_in_tex"; \
    then \
      ${ECHO} -n "  [W] Overfull \\hbox ($$too_wide) in $$file"; \
    else \
      ${ECHO} -n "  [W] Overfull \\hbox ($$too_wide) in $$file at $$linenum_in_tex"; \
    fi; \
    ${PRINT_message}; \
    ${ECHO} "      => Check page $$page and line $$linenum_in_log in ${1}.log."; \
  fi; \
  ${call clean_message,${1}}

o_vbox = \
  linenum_in_log=$$(${ECHO} "$$line" | ${SED} --quiet 's|^\(.*\):.*|\1|p'); \
  line_in_log=$$(${HEAD} --lines=$$linenum_in_log ${1}.log1 \
                 | ${TAIL} --lines=1); \
  too_high=$$(${ECHO} "$$line_in_log" \
              | ${SED} --quiet 's|.*(\(.*pt\) too high).*|\1|p'); \
  ${call SET_page,${1}.log1,$${linenum_in_log}}; \
  cutting_line_in_log=$$linenum_in_log; \
  ${call SET_file,${1}.log1}; \
  if test -z "$$file"; \
  then \
    ${ECHO} "  [W] Overfull \\vbox ($$too_high) at page $$page."; \
  else \
    ${ECHO} "  [W] Overfull \\vbox ($$too_high) in $$file."; \
    ${ECHO} "      => Check page $$page."; \
  fi

slide_overfull = \
  linenum_in_log=$$(${ECHO} "$$line" \
                    | ${SED} --quiet 's|^\(.*\):LaTeX Warning:.*|\1|p'); \
  line_in_log=$$(${HEAD} --lines=$$linenum_in_log ${1}.log1 \
                 | ${TAIL} --lines=1); \
  points=$$(${ECHO} "$$line_in_log" \
            | ${SED} --quiet 's|.* by \(.*pt\) .*|\1|p'); \
  ${call SET_page,${1}.log1,$${linenum_in_log}}; \
  cutting_line_in_log=$$linenum_in_log; \
  ${call SET_file,${1}.log1}; \
  if test -z "$$file"; \
  then \
    ${ECHO} "  [W] Slide overfull ($$points) at page $$page."; \
  elif test -e "$$file"; \
    then \
      ${ECHO} "  [W] Slide overfull ($$points) in $$file."; \
      ${ECHO} "      => Check page $$page."; \
    else \
      ${ECHO} "  [W] Slide overfull ($$points) at page $$page."; \
      ${ECHO} "      => Correct previous warning to get the file name."; \
  fi


show_detailed_under_overfulls = \
  ${CP} --force ${1}.log ${1}.log1; \
    grep --line-number rfull ${1}.log 2>&1 \
  | while read line; do \
      slide_overfull=$$(${ECHO} "$$line" \
                        | ${SED} --quiet 's|LaTeX Warning: Slide .* overfull .*|yes|p'); \
      if test -z "$$slide_overfull"; \
      then \
        kind=$$(${ECHO} "$$line" | ${AWK} '{ print $$1 $$2 }'); \
      else \
        kind=slide_overfull; \
      fi; \
      case "$$kind" in \
        [0-9]*:Underfull\hbox) ${call u_hbox,${1}};; \
        [0-9]*:Underfull\vbox) ${call u_vbox,${1}};; \
        [0-9]*:Overfull\hbox) ${call o_hbox,${1}};; \
        [0-9]*:Overfull\vbox) ${call o_vbox,${1}};; \
        slide_overfull) ${call slide_overfull,${1}};; \
      esac; \
    done

# ------------------------------------------------------------------------
# Unused LaTeX option
#
unused_latex_option = \
  unused=$$(grep --context=1 "Unused global option(s):" ${1}.log); \
  if test -n "$$unused"; \
  then \
    ${ECHO} "  [W]" $$(${ECHO} $$unused | ${TR} '\n' ' '); \
  fi

# ------------------------------------------------------------------------
# Hyperref warnings
#
hyperref_warnings = \
    grep --after-context=1 "Package hyperref Warning: Token not allowed" ${1}.log 2>&1 \
  | while read warning; do \
      if test "$$warning" != "--"; \
      then \
        ${ECHO} "  [W] $$warning"; \
      fi; \
    done; \
    bookmark=$$(grep "Package hyperref Warning: bookmark level" ${1}.log 2>&1);\
    if test -n "$$bookmark"; \
    then \
      ${ECHO} "  [W] $$bookmark"; \
    fi

# ------------------------------------------------------------------------
# Status of document processing
#
# When the document is up-to-date, the status of the document
# processing is displayed, as a reminder. Two cases occur: with or
# without bibliographies.
#
# Removed  ${if ${OCW_WARNING}, ${ECHO} ${OCW_WARNING};}
#
show_common_status = \
  if test ! -e ${1}.log; \
  then \
    ${ECHO} "TeX log file ${call loc_of,${1}.log} is missing."; \
  else \
    ${call show_detailed_under_overfulls,${1}}; \
    ${call find_latex_error,${1},log1}; \
    if test -z "$$latex_error"; \
    then \
      ${if ${TOC_WARNING}, ${ECHO} ${TOC_WARNING};} \
      ${call no_file_warning,${1}}; \
      ${call undefined_ref,${1}}; \
      ${call find_all_missing_cit,${1}}; \
      ${call multiple_labels,${1}}; \
    elif ! (grep ${1} .errmsg > /dev/null 2>&1); \
      then \
        ${if ${DEBUG},${ECHO} "[DBG D] Adding ${1} to .errmsg";} \
        ${ECHO} ${1} >> .errmsg; \
    fi; \
    ${call unused_latex_option,${1}}; \
    ${call hyperref_warnings,${1}}; \
  fi


#   bib=$$(${SED} --quiet 's|^ *\\bibliography[{]\([^{%} ]\+\)[}].*|\1|p' \
#              $$blg_basename.tex \
#          | ${TR} --delete ' ' \
#         | ${SED} --expression='s|,|.bib |g' \
#               --expression='s|$$|.bib|g'); \
#
bib_status = \
  bib=${1}.bib; \
  case ${call num_of,bib} in \
    1) ${ECHO} "Status of bibliography $$bib:";; \
    2) ${ECHO} "Status of bibliographies" \
            $$(${ECHO} $$bib | ${SED} 's| | and |g'):;; \
    *) ${ECHO} "Status of bibliographies" \
            $$(${ECHO} $$bib | ${SED} 's| |,|g'):;; \
  esac

show_status = \
  ${call show_common_status,${1}}; \
  ${call SET_slave_base_blg,${1}}; \
  if test -n "$$slave_base_blg"; \
  then \
    for base_blg in $$slave_base_blg; do \
      blg=$$base_blg.blg; \
      if test ! -e $$blg; \
      then \
        ${ECHO} "BibTeX log file $$blg is missing."; \
      else \
        ${call bib_status,$${base_blg}}; \
        ${call SET_warnings_in_blg,$${base_blg}}; \
        ${SET_generic_warnings_in_blg}; \
        ${PRINT_generic_warnings_in_blg}; \
        ${SET_num_errors}; \
        ${call errors_in_blg,$${num_errors}}; \
        if test -z "$$num_errors" -a -z "$$generic_warnings_in_blg"; \
        then \
          ${ECHO} "nothing to report."; \
        fi; \
      fi; \
    done; \
  fi


# ------------------------------------------------------------------------
#
.PHONY: FORCE
FORCE: ;

# ------------------------------------------------------------------------
# Remaking DVIs
#
# Two cases occur: with or without bibliographies. We also handle the
# special connection with the OCaml makefile (pretty-printing
# facility).
#
make_figure = \
  ${ECHO} -n "Making figure ${call loc_of,${1}.dvi} from ${call loc_of,${1}.tex}..."; \
  ${call latex,${1}}; \
  if test "$$latex_status" = "passed"; \
  then \
    ${call record_latex_success,${1}}; \
  fi

ifeq (${UPDATE},yes)
  ifeq (${FAKE},yes)
make_dvi = \
  if test -n "$?"; \
  then \
    ${if ${DEBUG}, ${ECHO} "[DBG 3] Touching .out-of-date in \`$@: $^'";} \
    ${if ${DEBUG}, ${ECHO} "[DBG 3bis] Prerequisites \`$?' are out of date.";} \
    touch .out-of-date; \
  fi
  else
make_dvi_bis = \
  ${if ${DEBUG}, ${ECHO} "[DBG F] Entering make_dvi_bis...";} \
  master_tex=${1}.tex; \
  ${call SET_slave_tex,${1}}; \
  ${call SET_slave_bbl,${1}}; \
  missing_bbl=$$(${SED} --quiet 's|^No file \([^ ]\+\.bbl\)\.|\1|p' ${1}.log \
                             2> /dev/null); \
  if test -z "$$slave_bbl" -a -z "$$missing_bbl"; \
  then \
    ${call show_under_overfulls,${1}}; \
    ${call SET_latex_error,${1}.log}; \
    if test -z "$$latex_error"; \
    then \
      ${call SET_undefined_ref,${1}}; \
      if test -n "$$undefined_ref"; \
      then \
        present_labels=; \
        for label in $$undefined_ref; do \
          if grep "\\\label[{]$$label[}]" $$slave_tex > /dev/null 2>&1; \
          then \
            present_labels="$$present_labels $$label"; \
          fi; \
        done; \
        missing_labels=; \
        remaining_labels=$$present_labels; \
        for undef_ref in $$undefined_ref; do \
          if test -z "$$remaining_labels"; \
          then \
            missing_labels="$$missing_labels $$undef_ref"; \
          else \
            fst_label=${call head,remaining_labels}; \
            if test "$$fst_label" = "$$undef_ref"; \
            then \
              remaining_labels=${call tail,remaining_labels}; \
            else \
              missing_labels="$$missing_labels $$undef_ref"; \
            fi; \
          fi; \
        done; \
        missing_labels=${call norm_list,missing_labels}; \
        if test "$$missing_labels" = "$$undefined_ref"; \
        then \
          ${call PRINT_undefined_ref,${1}}; \
          if test -e ${1}.dvi0; \
          then \
            ${CP} --force ${1}.dvi0 ${1}.dvi; \
          fi; \
        else \
          ${ECHO} -n "Recompiling document to solve references..."; \
          ${call latex,${1}}; \
          if test "$$latex_status" = "passed"; \
          then \
            ${call undefined_ref,${1}}; \
            ${call multiple_labels,${1}}; \
          fi; \
        fi; \
        toc=$$(grep '^[^%]*\\tableofcontents' $$master_tex 2> /dev/null); \
        if test -n "$$toc"; \
        then \
          ${ECHO} -n "Recompiling to merge table of contents..."; \
          ${call latex,${1}}; \
        fi; \
      else \
        ${call SET_label_change,${1}}; \
        if test -n "$$label_change"; \
        then \
          ${ECHO} -n "Recompiling to solve possible label changes..."; \
          ${call latex,${1}}; \
          if test "$$latex_status" = "passed"; \
          then \
            ${call multiple_labels,${1}}; \
          fi; \
        else \
          toc=$$(grep '^[^%]*\\tableofcontents' $$master_tex 2> /dev/null); \
          if test -n "$$toc"; \
          then \
            ${ECHO} -n "Recompiling to merge table of contents..."; \
            ${call latex,${1}}; \
          elif test -e ${1}.dvi0; \
            then ${CP} --force ${1}.dvi0 ${1}.dvi; \
          fi; \
        fi; \
      fi; \
      ${call find_all_missing_cit,${1}}; \
    fi; \
    if test ${1}.dvi0 -nt ${1}.dvi; \
    then \
      ${CP} --force ${1}.dvi0 ${1}.dvi; \
    fi; \
  else \
    ${call SET_latex_error,${1}.log}; \
    if test -z "$$latex_error"; \
    then \
      make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                                $$slave_bbl $$missing_bbl \
                                DOC:=${1} \
                                INCL_DEP:=no \
                                INCL_BIBLIO:=yes}"; \
      ${if ${VERB},${ECHO} "[VRB 2] Calling $$make_cmd";} \
      eval $$make_cmd; \
      if test -e .ran-bibtex; \
      then \
        ${RM} --force .ran-bibtex; \
        ${ECHO} -n "Merging document and bibliography..."; \
        ${call latex,${1}}; \
        if test "$$latex_status" = "passed"; \
        then \
          ${call multiple_labels,${1}}; \
          if grep 'Citation .* undefined' ${1}.log > /dev/null 2>&1; \
          then \
            ${ECHO} -n "Recompiling document to solve citations..."; \
            ${call latex,${1}}; \
            if test "$$latex_status" = "passed"; \
            then \
              ${call find_add_missing_cit,${1}}; \
            fi; \
          fi; \
        fi; \
      fi; \
      ${call undefined_ref,${1}}; \
      ${call show_under_overfulls,${1}}; \
    fi; \
    if test ${1}.dvi0 -nt ${1}.dvi; \
    then \
      ${CP} --force ${1}.dvi0 ${1}.dvi; \
    fi; \
  fi

make_dvi = \
  merged_sorted_lists=$$(${ECHO} ${DOC} ${1} \
                         | ${TR} ' ' '\n' \
                         | ${SORT} --dictionary-order \
                         | ${UNIQ} \
                         | ${TR} '\n' ' '); \
  if test "$$merged_sorted_lists" = "${DOC} "; \
  then \
    ${if ${DEBUG},${ECHO} "[DBG 6] Updating a master document.";} \
    make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                              ${1}.dvi0 \
                              DOC:=${1} \
                              INCL_DEP:=yes \
                              INCL_BIBLIO:=yes}"; \
    ${if ${VERB},${ECHO} "[VRB 1] Calling $$make_cmd";} \
    eval $$make_cmd; \
    ${call make_dvi_bis,${1}}; \
  else \
    ${if ${DEBUG},${ECHO} "[DBG B] Making a figure [${1}]";} \
    case ${firstword ${MAKECMDGOALS}} in \
      *.dvi0) \
        if ! (grep ${1} .errors > /dev/null 2>&1); \
        then \
          ${call make_figure,${1}}; \
        fi;; \
      *) ${call make_figure,${1}};; \
    esac; \
  fi

  endif
endif

PRINT_previous_errors = \
  for tex_basename in $$(${CAT} .errors); do \
    merged_sorted_lists=$$(${ECHO} ${DOC} $$tex_basename \
                           | ${TR} ' ' '\n' \
                           | ${SORT} --dictionary-order \
                           | ${UNIQ} \
                           | ${TR} '\n' ' '); \
    if test "$$merged_sorted_lists" != "${DOC} "; \
    then \
      ${ECHO} -n "Making ${call loc_of,$${tex_basename}}.dvi from ${call loc_of,$${tex_basename}}.tex..."; \
      ${call latex_failure,$${tex_basename}}; \
    fi; \
  done

pre_make = \
  if test -e .errors; \
  then \
    keep_dep=yes; \
  else \
    keep_dep=no; \
  fi; \
  make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                            ${1}${2}.${3} \
                            DOC:=${1} \
                            UPDATE:=yes \
                            FAKE:=yes \
                            INCL_DEP:=yes \
                            KEEP_DEP:=$$keep_dep \
                            INCL_BIBLIO:=yes}"; \
  ${if ${VERB},${ECHO} "[VRB 3] Calling $$make_cmd";} \
  eval $$make_cmd; \
  if test -e .out-of-date; \
  then \
    case ${3} in \
      dvi) \
        make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                                  ${1}${2}.${3} \
                                  DOC:=${1} \
                                  UPDATE:=yes \
                                  FAKE:=no \
                                  INCL_DEP:=yes \
                                  KEEP_DEP:=$$keep_dep \
                                  INCL_BIBLIO:=yes}"; \
        ${if ${VERB},${ECHO} "[VRB D] Calling $$make_cmd";} \
        eval $$make_cmd;; \
      ps|eps) \
        if test -n "${strip ${HREF_PDF}}" \
                -a -e .built-pdf; \
        then \
          ${RM} --force .built-pdf; \
          make_cmd="${strip ${MAKE} --file=Makefile \
                                    --no-builtin-rules \
                                    mostlyclean \
                                    DOC:=${1}}"; \
          ${if ${VERB},${ECHO} "[VRB C] Calling $$make_cmd";} \
          eval $$make_cmd; \
        fi; \
        make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                                  ${1}${2}.${3} \
                                  DOC:=${1} \
                                  UPDATE:=yes \
                                  FAKE:=no \
                                  INCL_DEP:=yes \
                                  KEEP_DEP:=$$keep_dep \
                                  INCL_BIBLIO:=yes}"; \
        ${if ${VERB},${ECHO} "[VRB 4] Calling $$make_cmd";} \
        eval $$make_cmd;; \
     pdf) \
        if test -n "${strip ${HREF_PDF}}" \
                -a ! -e .built-pdf; \
        then \
          make_cmd="${strip ${MAKE} --file=Makefile \
                                    --no-builtin-rules \
                                    mostlyclean \
                                    DOC:=${1}}"; \
          ${if ${VERB},${ECHO} "[VRB F] Calling $$make_cmd";} \
          eval $$make_cmd; \
          touch .built-pdf; \
        fi; \
        make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                                  ${1}${2}.${3} \
                                  DOC:=${1} \
                                  DEF:='${HREF_PDF}' \
                                  UPDATE:=yes \
                                  FAKE:=no \
                                  INCL_DEP:=yes \
                                  KEEP_DEP:=$$keep_dep \
                                  INCL_BIBLIO:=yes}"; \
        ${if ${VERB},${ECHO} "[VRB 10] Calling $$make_cmd";} \
        eval $$make_cmd;; \
    esac; \
    ${RM} --force .out-of-date; \
    if test -s .errors; \
    then \
      if test -s .errmsg; \
      then \
        for tex_basename in $$(${CAT} .errors); do \
          if ! (grep $$tex_basename .errmsg > /dev/null 2>&1); \
          then \
            ${ECHO} -n "Making ${call loc_of,$${tex_basename}}.dvi from ${call loc_of,$${tex_basename}}.tex..."; \
            ${call latex_failure,$${tex_basename}}; \
          fi; \
        done; \
      else \
        ${PRINT_previous_errors}; \
      fi; \
    fi; \
  else \
    if test -z "${4}"; \
    then \
      if test -s .errors; \
      then \
        ${PRINT_previous_errors}; \
      fi; \
      ${ECHO} "Document ${call loc_of,${1}${2}.${3}} is up-to-date."; \
      log_basename=$$(${ECHO} ${1}.${3} | ${SED} 's/\.eps\|\.ps\|\.dvi\|\.pdf//g'); \
      ${call show_status,$${log_basename}}; \
    elif test "${4}" = "short"; \
    then \
      ${ECHO} "Document ${call loc_of,${1}${2}.${3}} is up-to-date."; \
    fi; \
  fi

mostlyclean::
	${RM} --force .built-pdf .out-of-date .errors .errmsg .titles

ifeq (${UPDATE},yes)
%.dvi::
	${ensure_DEPDIR}
	${call make_dvi,$*}
else
%.dvi:: FORCE
	${call pre_make,$*,,dvi,${SILENT}}
endif

ifneq (${DOC},)
mostlyclean::
	if test -f . ${DOC:%=-o -e %.dvi}; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting DVI files...";} \
          ${RM} --force ${DOC:%=%.dvi}; \
          ${if ${VERB},${ECHO} " done.";} \
        fi
endif

# ------------------------------------------------------------------------
# Special `dvi' rule.
#
.PHONY: dvi
ifeq (${DOC},)
dvi:
	@${ECHO} "No LaTeX document to process."
else
dvi:
	make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                                  ${DVI}}"; \
        ${if ${VERB},${ECHO} "[VRB 5] Calling $$make_cmd";} \
        eval $$make_cmd
endif

# ------------------------------------------------------------------------

record_excerpt = \
  if ! (grep ${1} .excerpts > /dev/null 2>&1); \
  then \
    ${ECHO} ${1} >> .excerpts; \
  fi

# ------------------------------------------------------------------------
# Rules whose targets are <document>-4up.ps and <document>-4up.pdf
#
# This rule creates 4up pages of the document in PostScript and PDF by
# means of `psnup'.
#
# Note: This section must be placed before section devoted to updating
# %.ps and %.pdf (first matching goal selects the corresponding rule).
#
ifneq (${4UPPS},)
  ifeq (${PSNUP},none)
%${4UP}${PAGES}.ps %${4UP}${PAGES}.pdf:
	${ECHO} "\`psnup' is not configured; skipping."
  else 
    ifeq (${UPDATE},yes)
${4UPPS}: %${4UP}${PAGES}.ps: FORCE
	make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                                  $*${PAGES}.ps \
                                  UPDATE:=yes \
                                  SILENT:=yes}"; \
        ${if ${VERB},${ECHO} "[VRB 14] Calling $$make_cmd";} \
        eval $$make_cmd
	if test $*${PAGES}.ps -nt $@; \
        then \
          ${ECHO} -n "Making ${call loc_of,$@} from ${call loc_of,$*${PAGES}.ps} using psnup..."; \
          psnup_cmd="${strip ${PSNUP} -r -d -4 $*${PAGES}.ps 2>&1 >| $@ \
                           | ${SED} --quiet 's|.*Wrote \(.*\)|(\1)|p'}"; \
          ${if ${VERB},${ECHO}; ${ECHO} "Calling $$psnup_cmd";} \
          info=$$(eval $$psnup_cmd); \
          if test -z "$$info"; \
          then \
            ${ECHO} " FAILED."; \
          else \
            ${ECHO} " done $$info."; \
          fi; \
          ${call record_excerpt, ${notdir $@}}; \
        fi
    else
${4UPPS}: %${4UP}${PAGES}.ps: FORCE
	${call pre_make,$*,${4UP}${PAGES},ps,${if ${SILENT},silent,short}}
    endif 
  endif
endif

ifneq (${4UPPDF},)
  ifneq (${PS2PDF},none)
    ifeq (${UPDATE},yes)
${4UPPDF}: %${4UP}${PAGES}.pdf: FORCE
	make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                                  ${@:.pdf=.ps} \
                                  UPDATE:=yes \
                                  SILENT:=yes}"; \
        ${if ${VERB},${ECHO} "[VRB 15] Calling $$make_cmd";} \
        eval $$make_cmd
	if test ${@:.pdf=.ps} -nt $@; \
        then \
          ${call use_ps2pdf,${@:.pdf=.ps},$@}; \
        fi
    else
${4UPPDF}: %${4UP}${PAGES}.pdf: FORCE
	${call pre_make,$*,${4UP}${PAGES},pdf,${if ${SILENT},silent,short}}
    endif
  else
%${4UP}${PAGES}.pdf: %${4UP}${PAGES}.ps
	${ECHO} " => Install \`ps2pdf' to make a PDF from $<."
  endif
endif

mostlyclean::
	if test -e .excerpts; \
        then \
          ${if ${VERB}, ${ECHO} -n "Deleting .excerpts...";} \
          ${RM} --force .excerpts; \
          ${if ${VERB}, ${ECHO} " done.";} \
        fi

#           files=$$(${CAT} .excerpts); \
#           ${if ${VERB}, ${ECHO} " done.";} \
#           for f in $$files; do \
#             ${if ${VERB}, ${ECHO} -n "Deleting $$f...";} \
#             ${RM} --force $$f; \
#             ${if ${VERB}, ${ECHO} " done.";} \
#           done; \

# ------------------------------------------------------------------------
# Booklet

# psbook document.ps | pstops -pa4 4:0@.7L(21cm,00)+1L@.7(21cm,14.8cm),2L@.7(21cm,00)+3L@.7(21cm,14.8cm) > output.ps

# Explanation of the commands:
# psbook rearranges the order of the pages of the original document.ps
# file into a new one, appropriate for double-face booklet printing; the
# output is then piped (via the | shell command) to pstops that acts on
# the pages to create new physical pages containing groups of logical
# pages from the old document, according to the following rules:

# -pa4 (final paper format is A4)
# 4: (group pages into 4-page booklets)
# 0 (page 0 from each group should be:
# @.7 (scaled by .7, which is the reciprocal of \sqrt{2}, that is the
# ratio between the original A4 paper format and the final reduced page
# size, which is an A5, aka half an A4: A4 has dimension in a \sqrt{2}
# ratio, and thus the .7) 

# L (rotated by a quarter of a circle to the left)
# (21cm,0) (translated to this position on the new physical page) )
# + (add the next page spec to this same side of the new physical page)
# 1 (page 1 from each group should be:
# @.7 (scaled by .7, which is the reciprocal of \sqrt{2}, that is the
# ratio between the original A4 paper format and the final reduced page
# size, which is an A5, aka half an A4: A4 has dimension in a \sqrt{2}
# ratio, and thus the .7) 

# L (rotated by a quarter of a circle to the left)
# (21cm,14.8) (translated to this position on the new physical page) ) 
# , (add the following page specs to the other side of the new physical
# page) and so on and so forth. If the original document is already in
# half/A4 format (a5paper) you can leave out the @.7 specs from the page
# rearrangements.

# ------------------------------------------------------------------------
# Rule whose target is <document>.ps or <document>.eps
#

# Let an arrow be oriented in the direction of increasing values of
# its label. Then, if we have %%BoundingBox a b c d
#
#              ^
#              |d
#  a   -----------------  c
# --->|                 |--->
#      -----------------
#              ^
#              | b
#
pages_and_bytes_of_ps = \
  num_of_pages=$$(${SED} --quiet 's|%%Pages: \([^ ]\+\).*|\1|p' ${1} \
            | ${HEAD} --lines=1); \
  size=$$(${LS} -Al --si ${1} | ${AWK} '{ print $$5 }'); \
  if test "$$num_of_pages" = "1" -o -z "$$num_of_pages"; \
  then \
    ${ECHO} -n " (1 page, $$size bytes)"; \
  elif test -n "$$num_of_pages"; \
    then \
      ${ECHO} -n " ($$num_of_pages pages, $$size bytes)"; \
  fi

ifeq (${FAKE},yes)
update_ps = \
  ${if ${DEBUG},${ECHO} "[DBG 2] Touching .out-of-date in \`$@: $<'";}\
  touch .out-of-date
else
update_ps = \
  if test -e "${2}"; \
  then \
    merged_sorted_lists=$$(${ECHO} ${DOC} ${1} \
                           | ${TR} ' ' '\n' \
                           | ${SORT} --dictionary-order \
                           | ${UNIQ} \
                           | ${TR} '\n' ' '); \
    if test "$$merged_sorted_lists" = "${DOC} "; \
    then \
      postscript=${1}${PAGES}.ps; \
      dvips_cmd="${strip ${DVIPS} ${DVIPS_OPT} ${PRINTER} \
                         ${2} -o $$postscript 2>&1 1>/dev/null}"; \
      ${if ${VERB},${ECHO} "[VRB 6] Calling $$dvips_cmd";} \
      ${ECHO} -n "Making ${call loc_of,$${postscript}} from ${call loc_of,${2}} using dvips..."; \
      err=$$(eval $$dvips_cmd); \
      bounding_box=; \
    else \
      postscript=${1}.ps; \
      dvips_cmd="${strip ${DVIPS} ${DVIPS_FIG_OPT} ${PRINTER} \
                         ${2} -o $$postscript 2>&1 1>/dev/null}"; \
      ${if ${VERB},${ECHO} "[VRB 8] Calling $$dvips_cmd";} \
      ${ECHO} -n "Making figure ${call loc_of,$${postscript}} from ${call loc_of,${2}} using dvips..."; \
      err=$$(eval $$dvips_cmd); \
      if test -r "${1}.bbx"; \
      then \
        bounding_box=$$(${CAT} ${1}.bbx); \
      fi; \
    fi; \
    ${call record_excerpt, ${notdir ${1}${PAGES}.ps}}; \
    if test -e "$$postscript"; \
    then \
      ${ECHO} -n " done"; \
      ${call pages_and_bytes_of_ps,$${postscript}}; \
      ${ECHO} "."; \
      if test -n "$$bounding_box"; \
      then \
        ${ECHO} -n "Patching $$postscript with user-defined bounding box..."; \
        ${PERL} -pi -e "s|%%BoundingBox: (.*)|$$bounding_box|g" $$postscript; \
        ${ECHO} " done."; \
      fi; \
      ${call record_time_stamp,$${postscript}}; \
    elif test -n "$$err"; \
      then \
        ${ECHO} " FAILED:"; \
        msg=$$(${ECHO} "$$err" | ${SED} --quiet 's|\(.*dvips:.*\)|\1|p');\
        ${ECHO} "$$msg"; \
      else \
        ${ECHO} " FAILED."; \
    fi; \
  fi
endif

ifeq (${DVIPS},none)
%.ps:
	@${ECHO} "\`dvips' is not configured; skipping."
else
  ifeq (${UPDATE},yes)
${PS_FROM_TEX}: %.ps: %.dvi
	${call update_ps,$*,$<}
    ifneq (${PAGES},)
${addsuffix ${PAGES}.ps,${TEX_BASE}}: %${PAGES}.ps: %.dvi
	${call update_ps,$*,$<}
    endif
${EPS_FROM_TEX}: %.eps : %.dvi
	${call update_ps,$*,$<}
  else
${PS_FROM_TEX}: FORCE
	${call pre_make,${@:.ps=},,ps,${SILENT}}
${EPS_FROM_TEX}: FORCE
	${call pre_make,${@:.eps=},,eps,${SILENT}}
    ifneq (${PAGES},)
${addsuffix ${PAGES}.ps,${TEX_BASE}}: %${PAGES}.ps: FORCE
	${call pre_make,$*,${PAGES},ps,${if ${SILENT},silent,short}}
    endif
  endif
endif

# ------------------------------------------------------------------------
# Special `ps', `pdf', `4up_ps' and `4up_pdf' rules.
#

.PHONY: ps

ifeq (${DOC},)
ps:
	@${ECHO} "No LaTeX document to process."
else
ps:
	make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                                  ${PS}}"; \
        ${if ${VERB},${ECHO} "[VRB 9] Calling $$make_cmd";} \
        eval $$make_cmd
endif

.PHONY: pdf

ifeq (${DOC},)
pdf:
	@${ECHO} "No LaTeX document to process."
else
pdf:
	make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                                  ${PDF}}"; \
        ${if ${VERB},${ECHO} "[VRB A] Calling $$make_cmd";} \
        eval $$make_cmd
endif

.PHONY: 4up_ps

ifeq (${DOC},)
4up_ps:
	@${ECHO} "No LaTeX document to process."
else
4up_ps:
	make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                                  ${4UPPS} \
                                  DOC:='${DOC}'}"; \
        ${if ${VERB},${ECHO} "[VRB B] Calling $$make_cmd";} \
        eval $$make_cmd
endif

.PHONY: 4up_pdf

ifeq (${DOC},)
4up_pdf:
	@${ECHO} "No LaTeX document to process."
else
4up_pdf:
	make_cmd="${strip ${MAKE} --file=Makefile --no-builtin-rules \
                                  ${4UPPDF} \
                                  DOC:='${DOC}' \
                                  PS2PDF:=@PS2PDF@}"; \
        ${if ${VERB},${ECHO} "[VRB 7] Calling $$make_cmd";} \
        eval $$make_cmd
endif

ifneq (${DOC},)
mostlyclean::
	if test -f . ${DOC:%=-o -e %.ps}; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting PostScripts...";} \
          ${RM} --force ${DOC:%=%.ps}; \
          ${if ${VERB},${ECHO} " done.";} \
        fi
endif


# ------------------------------------------------------------------------
# Fonts and graphics
#
# Some package selections lead to unreadable or incomplete PDF. We
# detect them, explain the problem and suggest a solution according
# to the current system configuration.
#
# UPDATE: Recent versions of Adobe Reader handle T1 encoding just fine.
#
# check_fonts = \
#   fontenc_opt=$$(${call find_opt,fontenc}); \
#   if test -z "${TIMES}" -a -z "${AE}" -a "$$fontenc_opt" = "T1"; \
#   then \
#     ${ECHO} "  [W] Some PDF viewers do not display T1 font encoding well."; \
#     ${ECHO} "      => Try packages {times} or {ae,aecompl} or {lmodern}."; \
#     ${ECHO} "         For maths: \usepackage{mathptmx}"; \
#     ${ECHO} "                 or \usepackage[psamsfonts]{amsfonts}.";\
#   fi; \
#   if test -n "${AMSFONTS}"; \
#   then \
#     options=$$(${call find_opt,amsfonts}); \
#     sought=psamsfonts; \
#     ${is_in}; \
#     if test "$$in" = "false"; \
#     then \
#       ${ECHO} " => Use \usepackage[psamsfonts]{amsfonts}."; \
#     fi; \
#   fi

check_graphics = \
  if test -n "${GRAPHICS}"; \
  then \
    options=$$(${call find_opt,graphics}); \
    sought=${1}; \
    ${is_in}; \
    if test "$$in" = "false"; \
    then \
      ${ECHO} " => Set \usepackage[$$sought]{graphics}."; \
    fi; \
  fi

check_hyperref = \
  if test -n "${HYPERREF}"; \
  then \
    options=$$(${call find_opt,hyperref}); \
    sought=${1}; \
    ${is_in}; \
    if test "$$in" = "false"; \
    then \
      ${ECHO} " => Set \usepackage[$$sought]{hyperref}."; \
    fi; \
  fi

#  ${check_fonts};
use_dvipdfm = \
  ${call check_graphics,dvipdfm}; \
  ${call check_hyperref,dvipdfm}; \
  ${ECHO} -n "Making ${call loc_of,${2}} from ${call loc_of,${1}} using dvipdfm..."; \
  dvipdfm_cmd="${strip ${DVIPDFM} ${DVIPDFM_OPT} -o ${2} ${1} 2>&1}"; \
  ${if ${VERB},${ECHO};${ECHO} "Calling $$dvipdfm_cmd";} \
  msg=$$(eval $$dvipdfm_cmd \
         | ${SED} --quiet 's|^\(.*\) bytes written|\1|p'); \
  if test -n "$$msg"; \
  then \
    ${ECHO} " done ($$msg bytes)."; \
    ${call record_excerpt, ${notdir ${2}}}; \
    ${call record_time_stamp,${2}}; \
  else \
    ${ECHO} " FAILED."; \
  fi

#  ${check_fonts};
use_dvipdf = \
  ${call check_graphics,dvipdf}; \
  ${call check_hyperref,dvipdf}; \
  ${ECHO} -n "Making ${call loc_of,${2}} from ${call loc_of,${1}} using dvipdf..."; \
  dvipdf_cmd="${DVIPDF} ${2} ${1} 2>&1"; \
  ${if ${VERB},${ECHO};${ECHO} "Calling $$dvipdf_cmd";} \
  msg=$$(eval $$dvipdf_cmd); \
  if test -n "$$msg"; \
  then \
    ${ECHO} " done ($$msg bytes)."; \
    ${call record_excerpt, ${notdir ${2}}}; \
    ${call record_time_stamp,${2}}; \
  else \
    ${ECHO} " FAILED."; \
  fi

#  ${check_fonts};
use_ps2pdf = \
  ${ECHO} -n "Making ${call loc_of,${2}} from ${call loc_of,${1}} using ps2pdf..."; \
  ps2pdf_cmd="${strip ${PS2PDF} ${PS2PDF_OPT} ${1} ${2} 2>&1}"; \
  ${if ${VERB},${ECHO};${ECHO} "Calling $$ps2pdf_cmd";} \
  msg=$$(eval $$ps2pdf_cmd); \
  if test -z "$$msg" -a -e ${2}; \
  then \
    size=$$(${LS} -Al --si ${2} | ${AWK} '{ print $$5 }'); \
    ${ECHO} " done ($$size bytes)."; \
    ${call record_excerpt, ${notdir ${2}}}; \
    ${call record_time_stamp,${2}}; \
  else \
    ${ECHO} " FAILED."; \
  fi

warn_pstricks = \
  ${ECHO} " => Since you use package \`pstricks', "; \
  ${ECHO} "    your PDF may lose graphics with \`${1}'."; \
  ${ECHO} "    You should install \`dvips'. Trying anyway..."

ifeq (${PSTRICKS},)
  ifneq (${DVIPDFM},none)
    ifeq (${UPDATE},yes)
      ifeq (${PAGES},)
${PDF_FROM_TEX}: %.pdf : %.dvi
      else
${addsuffix ${PAGES}.pdf,${TEX_BASE}}: %${PAGES}.pdf: %.dvi
      endif
      ifeq (${FAKE},yes)
	${if ${DEBUG},${ECHO} "[DBG 4] Touching .out-of-date";} \
        touch .out-of-date
      else
	${call use_dvipdfm,$<,$@}
      endif
    else
%${4UP}${PAGES}.pdf: FORCE
	${call pre_make,$*,${4UP}${PAGES},pdf,${if ${SILENT},silent,short}}
%${PAGES}.pdf: FORCE
	${call pre_make,$*,${PAGES},pdf,${if ${SILENT},silent,short}}
    endif
  else # DVIPDFM = none
    ifneq (${PS2PDF},none)
      ifneq (${DVIPS},none)
%.pdf: %.ps
	${call use_ps2pdf,$<,$@}
      else # DVIPS = none
        ifneq (${DVIPDF},none)
          ifeq (${PAGES},)
${PDF_FROM_TEX}: %.pdf : %.dvi
          else
${addsuffix ${PAGES}.pdf,${TEX_BASE}}: %${PAGES}.pdf: %.dvi
          endif
	${call use_dvipdf,$<,$@}
        else # DVIPDF = none
          ifeq (${PAGES},)
${PDF_FROM_TEX}: %.pdf : %.dvi
          else
${addsuffix ${PAGES}.pdf,${TEX_BASE}}: %${PAGES}.pdf: %.dvi
          endif
	${ECHO} " => Install \`dvips' to make a PDF from $<."
        endif
      endif
    else # PS2PDF = none
      ifneq (${DVIPDF},none)
          ifeq (${PAGES},)
${PDF_FROM_TEX}: %.pdf : %.dvi
          else
${addsuffix ${PAGES}.pdf,${TEX_BASE}}: %${PAGES}.pdf: %.dvi
          endif
	${call use_dvipdf,$<,$@}
      else # DVIPDF = none
          ifeq (${PAGES},)
${PDF_FROM_TEX}: %.pdf : %.dvi
          else
${addsuffix ${PAGES}.pdf,${TEX_BASE}}: %${PAGES}.pdf: %.dvi
          endif
	${ECHO} " => Install \`dvipdfm' or \`ps2pdf' to make a PDF from $<."
      endif
    endif
  endif
else # PSTRICKS = pstricks
  ifneq (${PS2PDF},none)
    ifneq (${DVIPS},none)
%.pdf: %.ps
	${call use_ps2pdf,$<,$@}
    else # DVIPS = none
      ifneq (${DVIPDFM},none)
          ifeq (${PAGES},)
${PDF_FROM_TEX}: %.pdf : %.dvi
          else
${addsuffix ${PAGES}.pdf,${TEX_BASE}}: %${PAGES}.pdf: %.dvi
          endif
	${call warn_pstricks,dvipdfm}
	${call use_dvipdfm,$<,$@}
      else # DVIPDFM = none
        ifneq (${DVIPDF},none)
          ifeq (${PAGES},)
${PDF_FROM_TEX}: %.pdf : %.dvi
          else
${addsuffix ${PAGES}.pdf,${TEX_BASE}}: %${PAGES}.pdf: %.dvi
          endif
	${call warn_pstricks,dvipdf}
	${call use_dvipdf,$<,$@}
        else # DVIPDF = none
          ifeq (${PAGES},)
${PDF_FROM_TEX}: %.pdf : %.dvi
          else
${addsuffix ${PAGES}.pdf,${TEX_BASE}}: %${PAGES}.pdf: %.dvi
          endif
	${ECHO} " => Install \`dvips' to make a PDF from $<."
        endif
      endif
    endif
  else # PS2PDF = none
    ifneq (${DVIPDFM},none)
      ifeq (${PAGES},)
${PDF_FROM_TEX}: %.pdf : %.dvi
      else
${addsuffix ${PAGES}.pdf,${TEX_BASE}}: %${PAGES}.pdf: %.dvi
      endif
	${call warn_pstricks,dvipdfm}
	${call use_dvipdfm,$<,$@}
    else # DVIPDFM = none
      ifneq (${DVIPDF},none)
        ifeq (${PAGES},)
${PDF_FROM_TEX}: %.pdf : %.dvi
        else
${addsuffix ${PAGES}.pdf,${TEX_BASE}}: %${PAGES}.pdf: %.dvi
        endif
	${call warn_pstricks,dvipdf}
	${call use_dvipdf,$<,$@}
      else # DVIPDF = none
        ifeq (${PAGES},)
${PDF_FROM_TEX}: %.pdf : %.dvi
        else
${addsuffix ${PAGES}.pdf,${TEX_BASE}}: %${PAGES}.pdf: %.dvi
        endif
	@${ECHO} " => Install \`ps2pdf' to make a PDF from $<."
      endif
    endif
  endif
endif

ifneq (${DOC},)
mostlyclean::
	if test -f . ${DOC:%=-o -e %.pdf}; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting PDF files...";} \
          ${RM} --force ${DOC:%=%.pdf}; \
          ${if ${VERB},${ECHO} " done.";} \
        fi
endif

# ========================================================================

delete_files = \
  if test -n "${1}"; \
  then \
    present_files=$$(${LS} ${1} 2> /dev/null); \
    if test -n "$$present_files"; \
    then \
      linear_present_files=$$(${ECHO} $$present_files | ${TR} '\n' ' '); \
      formatted_present_files=$$(${ECHO} $$present_files \
                                 | ${TR} --delete '\n' \
                                 | ${TR} ' ' ','); \
      ${if ${VERB}, ${ECHO} -n "Deleting $$formatted_present_files...";} \
      ${RM} --force $$linear_present_files; \
      ${if ${VERB}, ${ECHO} " done.";} \
    fi; \
  fi

delete_ext = \
  present_files=$$(${LS} *.${1} 2> /dev/null); \
  if test -n "$$present_files"; \
  then \
    ${if ${VERB},${ECHO} -n "Deleting ${2}...";} \
    ${RM} --force *.${1}; \
    ${if ${VERB},${ECHO} " done.";} \
  fi

delete_file = \
  if test -e "${1}"; \
  then \
    ${if ${VERB}, ${ECHO} -n "Deleting ${1}...";} \
    ${RM} --force ${1}; \
    ${if ${VERB}, ${ECHO} " done.";} \
  fi

ifneq (${DOC},)
mostlyclean::
	for document in ${DOC}; do \
          ${call delete_file,$${document}.aux}; \
        done
endif

mostlyclean::
	${strip ${RM} --force ${GENDOC}.* ${TOC}}

ifneq (${DOC},)
mostlyclean::
	if test -f . ${DOC:%=-o -e %.log}; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting TeX log files...";} \
          ${RM} --force ${DOC:%=%.log}; \
          ${if ${VERB}, ${ECHO} " done.";} \
        fi
	${RM} --force ${DOC:%=%.log1}
endif

# ========================================================================
# Making a `Makefile.info' file by cutting the head of this makefile.
#
.PHONY: info
info:
	${ECHO} -n "Creating documentation Makefile.info..."
	line_num=$$(grep --line-number 'END DOC' Makefile.in \
                    | ${HEAD} --lines=1 \
                    | ${SED} --quiet 's|^\([0-9]*\):.*|\1|p'); \
        line_num=$$(${EXPR} $$line_num - 2); \
          ${HEAD} --lines=$$line_num Makefile.in \
        | ${TR} --delete '#' >| Makefile.info
	${ECHO} " done."

# ========================================================================
# Extracting excerpts (parts)
#
.PHONY: pp
.PRECIOUS: %.pp

ifeq (${PARTS},)
%.pp:
	${ECHO} "  [E] No documents found."
	${ECHO} "      => Set variable DOC to the document basenames."
pp:
	${ECHO} "  [E] No documents found."
	${ECHO} "      => Set variable DOC to the document basenames."
else
%.pp:
	${call pre_make,$*,,dvi,${if ${SILENT},silent,short}}
	if test -e $*.log; \
        then \
          ${ECHO} -n "Extracting starting lines from $*.log..."; \
          opening_tags=$$(grep --line-number \
                               '<part basename=".*" title=.*' \
                               $*.log \
                          | ${SED} 's|^\([^:]*\):.*|\1|g'); \
          if test -z "$$opening_tags"; \
          then \
            ${ECHO} " done (none). Skipping."; \
          else \
            ${ECHO} " done."; \
            ${ECHO} -n "Extracting tags from $*.log..."; \
            filtered_tags=$$(grep --after-context=1 \
                                  '<part basename=".*" title=.*' \
                                  $*.log \
                             | ${TR} --delete '\n' \
                             | ${SED} 's|>\([^<]*\)|>|g' \
                             | ${TR} '>' '\n'); \
            if test -z "$$filtered_tags"; \
            then \
              ${ECHO} " done (none). Skipping."; \
            else \
              ${ECHO} " done."; \
              ${ECHO} -n "Extracting basenames and titles from tags..."; \
              openings=$$(${ECHO} "$$filtered_tags" \
                          | ${SED} 's|^<part basename="\(.*\)" title="\(.*\)"|\1:\2|g'); \
              if test -n "$$openings"; \
              then \
                ${ECHO} "$$openings" >| .titles; \
                ${ECHO} " done."; \
                ${ECHO} -n "Extracting ending lines from $*.log..."; \
                closing_tags=$$(grep --line-number '</part>' $*.log \
                                | ${SED} 's|^\(.*\):.*|\1|g'); \
                tags="$$opening_tags"$$'\n'"$$closing_tags"; \
                ${ECHO} " done."; \
                ${ECHO} -n "Sorting lines..."; \
                sorted_tags=$$(${ECHO} "$$tags" | ${SORT} --numeric-sort); \
                ${ECHO} " done."; \
                ${ECHO} -n "Pasting page ranges, basenames and titles to $*.pp..."; \
                  ${ECHO} "$$sorted_tags" \
                | while read line; do \
                    ${call SET_page,$*.log,$${line}}; \
                    start=$$page; \
                    read next; \
                    ${call SET_page,$*.log,$${next}}; \
                    end=$$(${EXPR} $$page - 1 2>/dev/null); \
                    ${ECHO} "$$start-$$end"; \
                  done \
                | ${PASTE} --delimiters=':' -  .titles >| $*.pp 2>/dev/null; \
                ${ECHO} " done."; \
                ${RM} --force .titles; \
              else \
                ${ECHO} " done (none). Skipping."; \
              fi; \
            fi; \
          fi; \
        else \
          ${ECHO} "  [E] $*.log not found."; \
        fi

pp: ${PARTS}

# 
#
format_doc = \
  if test "${4}" = "1"; \
  then \
    formatted_page_num="(1 page, "; \
  else \
    formatted_page_num="(${4} pages, "; \
  fi; \
  last=PDF; \
  if test -e ${1}.pdf; \
  then \
    ${ECHO} -n "       in <a href=\"${1}.pdf\">PDF</a>" >> ${2}; \
    pdf_size=$$(${LS} -Al --si ${1}.pdf | ${AWK} '{ print $$5 }'); \
    ${ECHO} -n " $$formatted_page_num" >> ${2}; \
    ${ECHO} "$$pdf_size bytes)" >> ${2}; \
  else \
    ${ECHO} "          <font color="red">The PDF is missing! <a href="mailto:rinderkn@konkuk.ac.kr">Please report.</a></font>" >> ${2}; \
  fi; \
  if test -e ${1}-4up.pdf; \
  then \
    pdf_size=$$(${LS} -Al --si ${1}-4up.pdf | ${AWK} '{ print $$5 }'); \
    ${ECHO} -n "       or <a href=\"${1}-4up.pdf\">4-up PDF</a>" >> ${2}; \
    ${ECHO} -n " (" >> ${2}; \
    if test -e ${1}-4up.ps; \
    then \
      num_of_pages=$$(${SED} --quiet 's|%%Pages: \([^ ]\+\).*|\1|p' ${1}-4up.ps \
                      | ${HEAD} --lines=1); \
      if test "$$num_of_pages" = "1"; \
      then \
        ${ECHO} -n "1 page, " >> ${2}; \
      else \
        ${ECHO} -n "$$num_of_pages pages, " >> ${2}; \
      fi; \
    fi; \
    ${ECHO} -n "$$pdf_size bytes)" >> ${2}; \
    if test "${3}" = "low"; \
    then \
      ${ECHO} ". </li>" >> ${2}; \
    else \
      ${ECHO} " <br>" >> ${2}; \
    fi; \
    last=4up_PDF; \
  fi; \
  if test -e ${1}.ps; \
  then \
    if test "${3}" != "low" -o -z "${TALK}"; \
    then \
      ${ECHO} -n "       or <a href=\"${1}.ps\">PostScript</a>" >> ${2}; \
      ps_size=$$(${LS} -Al --si ${1}.ps | ${AWK} '{ print $$5 }'); \
      ${ECHO} -n " $$formatted_page_num" >> ${2}; \
      ${ECHO} -n " $$ps_size bytes)" >> ${2}; \
      if test "$$last" = "PDF"; \
      then \
        ${ECHO} ". </li>" >> ${2}; \
      else \
        ${ECHO} >> ${2}; \
      fi; \
    fi; \
  fi; \
  if test -e ${1}-4up.ps -a "${3}" != "low"; \
  then \
    ${ECHO} -n "       or <a href=\"${1}-4up.ps\">4-up PostScript</a>" >> ${2}; \
    (${call pages_and_bytes_of_ps,${1}-4up.ps}) >> ${2}; \
    ${ECHO} ". </li>" >> ${2}; \
  fi; \
  ${ECHO} >> ${2}


.PHONY: parts
parts: ${PARTS}
	for pp in ${PARTS}; do \
         if test -n "$$pp"; \
         then \
            doc=$$(${EXPR} match "$$pp" "\(.*\)\.pp"); \
            ${RM} --force $$pp.html; \
            make_cmd="${strip ${MAKE} --file=Makefile \
                                      --no-builtin-rules \
                                      ${if ${TALK},4up_pdf pdf,pdf} \
                                      DOC:=$$doc \
                                      SILENT:=short}"; \
            ${if ${VERB}, ${ECHO} "[VRB 16] Calling $$make_cmd";} \
            eval $$make_cmd; \
            title=$$(grep --after-context=1 '<doc name=.*' $$doc.log \
                     | ${TR} --delete '\n' \
                     | ${SED} 's|<doc name="\([^"]*\)".*|\1|g' \
                     | ${SED} "s|\\\'||g" \
                     | ${SED} "s|\\\^||g" \
                     | ${TR} --delete '`' \
                     | ${TR} --delete '\\'); \
            ${if ${VERB}, ${ECHO} -n "Writing \"$$title\" to .$$doc.title...";} \
            ${ECHO} "$$title" >| .$$doc.title; \
            ${if ${VERB}, ${ECHO} " done.";} \
            options=$$(${call find_opt,babel}); \
            sought=francais; \
            ${is_in}; \
            if test "$$in" = "false"; \
            then \
              ${if ${VERB}, ${ECHO} -n "Writing \"english\" to .$$doc.lang...";} \
              ${ECHO} "english" >| .$$doc.lang; \
            else \
              ${if ${VERB}, ${ECHO} -n "Writing \"$$sought\" to .$$doc.lang...";} \
              ${ECHO} $$sought >| .$$doc.lang; \
            fi; \
            ${if ${VERB}, ${ECHO} " done.";} \
            if test -n "${TALK}"; \
            then \
              ${ECHO} -n "  <li> <b><i> All the slides in one file </i></b>" >> $$pp.html; \
            else \
              if test -z "$$title"; \
              then \
                ${ECHO} -n "  <li> <b><i> Document </i></b>" >> $$pp.html; \
              else \
                ${ECHO} -n "  <li> <b> $$title </b>" >> $$pp.html; \
              fi; \
            fi; \
            if test -e $$doc.log; \
            then \
              num_of_pages=$$(${SED} --quiet 's|.*(\([0-9]\) page.*|\1|p' $$doc.log 2>/dev/null); \
            fi; \
            if test -z "$$num_of_pages" -o -e $$doc.ps; \
            then \
              num_of_pages=$$(${SED} --quiet 's|%%Pages: \([^ ]\+\).*|\1|p' $$doc.ps \
                              | ${HEAD} --lines=1 2>/dev/null); \
            fi; \
            if test -z "${TALK}" -a -e .$$doc.dvi.date; \
            then \
              today=$$(${CAT} .$$doc.dvi.date); \
              ${ECHO} " (last updated $$today) </br>" >> $$pp.html; \
            else \
              ${ECHO} " </br>" >> $$pp.html; \
            fi; \
            ${call format_doc,$${doc},$${pp}.html,${FRAG},$${num_of_pages}}; \
            if test -e $$pp; \
            then \
              ${CAT} $$pp \
            | while read line; do \
                page_range=$$(${EXPR} match "$$line" "\([^:]*\):.*"); \
                if test -n "$$doc" -a -n "$$page_range"; \
                then \
                  make_cmd="${strip ${MAKE} --file=Makefile \
                                            --no-builtin-rules \
                                            4up_pdf pdf \
                                            DOC:=$$doc \
                                            PP=$$page_range}"; \
                  ${if ${VERB},${ECHO} "[VRB 13] Calling $$make_cmd";} \
                  eval $$make_cmd; \
                  filename=$$(${EXPR} match "$$line" "[^:]*:\([^:]*\):.*"); \
                  if test $$doc-$$page_range.ps -nt $$filename.ps; \
                  then \
                    ${ECHO} -n "Copying $$doc-$$page_range.ps to $$filename.ps..."; \
                    ${CP} --force $$doc-$$page_range.ps $$filename.ps; \
                    ${ECHO} " done."; \
                  fi; \
                  if test $$doc-$$page_range.pdf -nt $$filename.pdf; \
                  then \
                    ${ECHO} -n "Copying $$doc-$$page_range.pdf to $$filename.pdf..."; \
                    ${CP} --force $$doc-$$page_range.pdf $$filename.pdf; \
                    ${ECHO} " done."; \
                  fi; \
                  if test $$doc-4up-$$page_range.ps -nt $$filename-4up.ps; \
                  then \
                    ${ECHO} -n "Copying $$doc-4up-$$page_range.ps to $$filename-4up.ps..."; \
                    ${CP} --force $$doc-4up-$$page_range.ps $$filename-4up.ps; \
                    ${ECHO} " done."; \
                  fi; \
                  if test $$doc-4up-$$page_range.pdf -nt $$filename-4up.pdf; \
                  then \
                    ${ECHO} -n "Copying $$doc-4up-$$page_range.pdf to $$filename-4up.pdf..."; \
                    ${CP} --force $$doc-4up-$$page_range.pdf $$filename-4up.pdf; \
                    ${ECHO} " done."; \
                  fi; \
                  title=$$(${EXPR} match "$$line" "[^:]*:[^:]*:\(.*\)"); \
                  ${ECHO} "  <li> <b>$$title</b> <br>" >> $$pp.html; \
                  first_page=$$(${EXPR} match "$$line" "\([^-]*\)-.*"); \
                  last_page=$$(${EXPR} match "$$line" "[^-]*-\([^:]*\):.*"); \
                  page_num=$$(${EXPR} $$last_page - $$first_page + 1); \
                  ${call format_doc,$${filename},$${pp}.html,${FRAG},$${page_num}}; \
                fi; \
              done; \
            fi; \
            ${ECHO} "Generation of $$(pwd)/$$pp.html is done."; \
          fi; \
        done

.PHONY: pack
  ifneq (${TAR}, none)
pack: #parts
	for pp in ${PARTS}; do \
          if test -f "$$pp"; \
          then \
            ${CAT} $$pp \
          | (while read line; do \
              filename=$$(${EXPR} match "$$line" "[^:]*:\([^:]*\):.*"); \
              documents=$$(${LS} $$filename.ps $$filename.pdf $$filename-4up.ps $$filename-4up.pdf 2> /dev/null); \
              if test -z "$$parts"; \
              then \
                parts="$$documents"; \
              else \
                parts="$$parts $$documents"; \
              fi; \
            done; \
            doc=$$(${EXPR} match "$$pp" "\(.*\)\.pp"); \
            ${ECHO} -n "Archiving documents in $$doc.tar.bz2..."; \
            main=$$(${LS} $$doc.ps $$doc.pdf $$doc-4up.ps $$doc-4up.pdf 2> /dev/null); \
            if ${TAR} --create --bzip2 --file=$$doc.tar.bz2 $$parts $$main; \
            then \
              ${ECHO} " done."; \
            else \
              ${ECHO} " FAILED: try yourself \`tar cjf $$doc.tar.bz2 $$parts'"; \
            fi); \
          else \
            doc=$$(${EXPR} match "$$pp" "\(.*\)\.pp"); \
            parts=; \
            for f in $$doc.ps $$doc.pdf; do \
              if test -f $$f; \
              then \
                if test -z "$$parts"; \
                then \
                  parts=$$f; \
                else \
                  parts="$$parts $$f"; \
                fi; \
              fi; \
            done; \
            if test -n "$$parts"; \
            then \
              ${ECHO} -n "Archiving $$parts in $$doc.tar.bz2..."; \
              if ${TAR} --create --bzip2 --file=$$doc.tar.bz2 $$parts; \
              then \
                ${ECHO} " done."; \
              else \
                ${ECHO} " FAILED: try yourself \`tar cjf $$doc.tar.bz2 $$parts'"; \
              fi; \
            fi; \
          fi; \
        done
  else
pack:
	@${ECHO} "\`tar' is not configured, ignoring."
  endif
endif

ifneq (${DOC},)
.PHONY: pack_html
  ifneq (${TAR}, none)
pack_html: #parts
	for doc in ${DOC}; do \
      if test -f $$doc.pp.html; \
      then \
        hrefs=$$(${SED} --quiet 's|.*<a href="\([^"]\+\)".*|\1|p' $$doc.pp.html); \
        objects=$$(${LS} $$hrefs 2> /dev/null); \
        if test -n "$$objects"; \
        then \
          ${ECHO} -n "Archiving documents in $$doc.tar.bz2..."; \
          if ${TAR} --create --bzip2 --file=$$doc.tar.bz2 $$objects; \
          then \
            ${ECHO} " done."; \
          else \
            ${ECHO} " FAILED: try yourself \`tar cjf $$doc.tar.bz2 $$objects'"; \
          fi; \
        else \
          ${ECHO} " No HTTP objects to pack."; \
        fi; \
      fi; \
    done
  else
pack_html:
	@${ECHO} "\`tar' is not configured, ignoring."
  endif
endif


delete_pack = \
  parts=$$(${LS} *.pp 2> /dev/null); \
  if test -n "$$parts"; \
  then \
    for pp in $$parts; do \
      doc=$$(${EXPR} match "$$pp" "\(.*\)\.pp"); \
      if test -e $$doc.tar.bz2; \
      then \
        ${if ${VERB}, ${ECHO} -n "Deleting $$doc.tar.bz2...";} \
        ${RM} --force $$doc.tar.bz2; \
        ${if ${VERB}, ${ECHO} " done.";} \
      fi; \
    done; \
  fi


delete_parts = \
  parts=$$(${LS} *.pp 2> /dev/null); \
  if test -n "$$parts"; \
  then \
    for pp in $$parts; do \
      doc=$$(${EXPR} match "$$pp" "\(.*\)\.pp"); \
      (${CAT} $$pp \
    | while read line; do \
        page_range=$$(${EXPR} match "$$line" "\([^:]*\):.*"); \
        filename=$$(${EXPR} match "$$line" "[^:]*:\([^:]*\):.*"); \
        if test -e "$$filename.ps"; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting $$filename.ps...";} \
          ${RM} --force $$filename.ps; \
          ${if ${VERB},${ECHO} " done.";} \
        fi; \
        if test -e "$$filename.pdf"; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting $$filename.pdf...";} \
          ${RM} --force $$filename.pdf; \
          ${if ${VERB},${ECHO} " done.";} \
        fi; \
        if test -e "$$doc-$$page_range.ps"; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting $$doc-$$page_range.ps...";} \
          ${RM} --force $$doc-$$page_range.ps; \
          ${if ${VERB},${ECHO} " done.";} \
        fi; \
        if test -e "$$doc-$$page_range.pdf"; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting $$doc-$$page_range.pdf...";} \
          ${RM} --force $$doc-$$page_range.pdf; \
          ${if ${VERB},${ECHO} " done.";} \
        fi; \
        if test -e "$$filename-4up.ps"; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting $$filename-4up.ps...";} \
          ${RM} --force $$filename-4up.ps; \
          ${if ${VERB},${ECHO} " done.";} \
        fi; \
        if test -e "$$filename-4up.pdf"; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting $$filename-4up.pdf...";} \
          ${RM} --force $$filename-4up.pdf; \
          ${if ${VERB},${ECHO} " done.";} \
        fi; \
        if test -e "$$doc-4up-$$page_range.ps"; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting $$doc-4up-$$page_range.ps...";} \
          ${RM} --force $$doc-4up-$$page_range.ps; \
          ${if ${VERB},${ECHO} " done.";} \
        fi; \
        if test -e "$$doc-4up-$$page_range.pdf"; \
        then \
          ${if ${VERB},${ECHO} -n "Deleting $$doc-4up-$$page_range.pdf...";} \
          ${RM} --force $$doc-4up-$$page_range.pdf; \
          ${if ${VERB},${ECHO} " done.";} \
        fi; \
      done); \
    done; \
 fi; \
 html_files=$$(${LS} *.pp.html 2> /dev/null); \
 if test -n "$$html_files"; \
 then \
   ${if ${VERB}, ${ECHO} -n "Deleting *.pp.html...";} \
   for html_file in $$html_files; do \
     ${RM} --force $$html_file; \
   done; \
   ${if ${VERB}, ${ECHO} " done.";} \
 fi; \
titles=$$(${LS} .*.title 2> /dev/null); \
if test -n "$$titles"; \
then \
  ${if ${VERB}, ${ECHO} -n "Deleting .*.title...";} \
  for title in $$titles; do \
    ${RM} --force $$title; \
  done; \
  ${if ${VERB}, ${ECHO} " done.";} \
fi; \
languages=$$(${LS} .*.lang 2> /dev/null); \
if test -n "$$languages"; \
then \
    ${if ${VERB}, ${ECHO} -n "Deleting .*.lang...";} \
    for language in $$languages; do \
      ${RM} --force $$language; \
    done; \
    ${if ${VERB}, ${ECHO} " done.";} \
fi; \
dates=$$(${LS} .*.date 2> /dev/null); \
if test -n "$$dates"; \
then \
  ${if ${VERB}, ${ECHO} -n "Deleting .*.date...";} \
  for time_stamp in $$dates; do \
    ${RM} --force $$time_stamp; \
  done; \
  ${if ${VERB}, ${ECHO} " done.";} \
fi

mostlyclean::
	${delete_parts}
	${delete_pack}


# ========================================================================
# Cleaning
#
clean::
	${strip ${RM} --force ${GENDOC}.* ${TOC}}
	${RM} --force .errors .errmsg \
                   .out-of-date .built-pdf \
                   missfont.log texput.log
	${call delete_file,Makefile.info}
	${call delete_ext,toc,tables of contents}
	if test -e .excerpts; \
        then \
          files=$$(${CAT} .excerpts); \
          ${if ${VERB}, ${ECHO} -n "Deleting .excerpts...";} \
          ${RM} --force .excerpts; \
          ${if ${VERB},${ECHO} " done.";} \
          for f in $$files; do \
            ${if ${VERB}, ${ECHO} -n "Deleting $$f...";} \
            ${RM} --force $$f; \
            ${if ${VERB},${ECHO} " done.";} \
          done; \
        fi
	${delete_parts}
	pp=$$(${LS} *.pp 2> /dev/null); \
    if test -n "$$pp"; \
    then \
      ${if ${VERB}, ${ECHO} -n "Deleting *.pp...";} \
      ${RM} --force *.pp; \
      ${if ${VERB}, ${ECHO} " done.";} \
    fi
	${delete_pack}
ifeq (${DOC},)
	${call delete_ext,blg,BibTeX log files}
	${call delete_ext,bbl,compiled bibliographies}
	${call delete_ext,dvi,DVI files}
	${call delete_ext,aux,TeX auxiliary files}
	${RM} --force *.dvi0 *.log1
	logs=$$(${LS} *.log 2> /dev/null | ${SED} 's|config\.log||g'); \
        ${call delete_files,$${logs}}; \
	ps_basenames=$$(${LS} *.ps 2> /dev/null | ${SED} 's|\.ps||g'); \
        for ps_basename in $$ps_basenames; do \
          if test -e $$ps_basename.tex; \
          then \
            ${call delete_file,$${ps_basename}.ps}; \
          fi; \
        done
	eps_basenames=$$(${LS} *.eps 2> /dev/null | ${SED} 's|\.eps||g'); \
        for eps_basename in $$eps_basenames; do \
          if test -e $$eps_basename.tex -o -e $$eps_basename.fig \
                  -o -e $$eps_basename.gif -o -e $$eps_basename.jpg; \
          then \
            ${call delete_file,$${eps_basename}.eps}; \
          fi; \
        done
	pdf_basenames=$$(${LS} *.pdf 2> /dev/null | ${SED} 's|\.pdf||g'); \
        for pdf_basename in $$pdf_basenames; do \
          if test -e $$pdf_basename.tex; \
          then \
            ${call delete_file,$${pdf_basename}.pdf}; \
          fi; \
        done
else
	${call delete_ext,aux,TeX auxiliary files}
	for document in ${DOC}; do \
          ${RM} --force $$document.dvi0; \
          ${call delete_file,$${document}.toc}; \
          ${call delete_file,$${document}.lof}; \
          ${call delete_file,$${document}.ent}; \
          ${call delete_file,$${document}.pdf}; \
          dep_file=${call pref_depdir,$${document}.dep}; \
          if test -s $$dep_file; \
          then \
            tex_basenames=$$(grep --only-matching '[-_[:alnum:]]\+\.tex' \
                                              $$dep_file \
                             | ${SED} 's|\.tex||g'); \
            bbl_basenames=$$(grep --only-matching '[-_[:alnum:]]\+\.bbl' \
                                              $$dep_file \
                             | ${SED} 's|\.bbl||g'); \
            eps_basenames=$$(grep --only-matching '[-_[:alnum:]]\+\.eps' \
                                                  $$dep_file \
                             | ${SED} 's|\.eps||g'); \
            ps_basenames=$$(grep --only-matching '[-_[:alnum:]]\+\.ps' \
                                                 $$dep_file \
                             | ${SED} 's|\.ps||g'); \
            filtered_eps_files=; \
            for eps_basename in $$eps_basenames; do \
              if test -e $$eps_basename.fig -o -e $$eps_basename.gif \
                      -o -e $$eps_basename.jpg; \
              then \
                filtered_eps_files="$$filtered_eps_files $$eps_basename.eps"; \
              fi; \
            done; \
            ${call delete_files,$${filtered_eps_files}}; \
            dependent_ps_files=$$document.ps; \
            dependent_aux_files=; \
            dependent_log_files=; \
            dependent_dvi_files=; \
            for ps_basename in $$ps_basenames; do \
              if test -e $$ps_basename.fig -o -e $$ps_basename.gif \
                      -o -e $$ps_basename.jpg; \
              then \
                dependent_ps_files="$$dependent_ps_files $$ps_basename.ps";\
              elif test -e $$ps_basename.tex; \
                then \
                dependent_ps_files="$$dependent_ps_files $$ps_basename.ps";\
                  if test -e $$ps_basename.aux; \
                  then \
                   dependent_aux_files="$$dependent_aux_files $$ps_basename.aux"; \
                  fi; \
                  if test -e $$ps_basename.log; \
                  then \
                   dependent_log_files="$$dependent_log_files $$ps_basename.log";\
                  fi; \
                  if test -e $$ps_basename.dvi; \
                  then \
                    dependent_dvi_files="$$dependent_dvi_files $$ps_basename.dvi"; \
                  fi; \
              fi; \
            done; \
            ${call delete_files,$${dependent_ps_files}}; \
            ${call delete_files,$${dependent_aux_files}}; \
            ${call delete_files,$${dependent_log_files}}; \
            ${call delete_files,$${dependent_dvi_files}}; \
            for tex_basename in $$tex_basenames; do \
              ${call delete_file,$${tex_basename}.ps}; \
              ${call delete_file,$${tex_basename}.dvi}; \
              ${call delete_file,$${tex_basename}.aux}; \
              ${call delete_file,$${tex_basename}.log}; \
            done; \
            for bbl_basename in $$bbl_basenames; do \
              ${call delete_file,$${bbl_basename}.bbl}; \
              ${call delete_file,$${bbl_basename}.blg}; \
            done; \
          else \
            ${call delete_file,$${document}.aux}; \
            ${call delete_file,$${document}.ps}; \
            ${call delete_file,$${document}.pdf}; \
            ${call delete_file,$${document}.dvi}; \
            ${RM} --force $$document.dvi0; \
          fi; \
          ${call delete_file,$${document}.log}; \
          ${RM} --force $$document.log1; \
          ${call delete_file,$${document}.bbl}; \
          ${call delete_file,$${document}.blg}; \
        done
endif
ifeq (${DEPDIR_EXISTS},yes)
	${if ${VERB},${ECHO} -n "Deleting dependences..."}
	${RM} --force --recursive ${DEPDIR}
	${if ${VERB},${ECHO} " done."}
endif

# Distribution clean by removing [emacs] temporary files, [configure]
# logs and `Makefile'.
#
AC_VERSION := @ac_version@

.PHONY: distclean
distclean:
	${MAKE} --file=Makefile --no-builtin-rules clean DOC:=
ifeq (${VERB},)
	if test -e config.cache -o -e config.log -o -e config.status; \
        then \
          ${RM} --force --recursive configure config.log config.status \
                                 autom4te.cache \
                                 autom4te-${AC_VERSION}.cache; \
        fi
	${RM} --force *~ .*~ \#*\# .\#*
	${RM} --force Makefile
else
	if test -e config.cache -o -e config.log -o -e config.status; \
        then \
          ${ECHO} -n "Deleting configurations${if ${LOC}, in ${LOC}}..."; \
          ${RM} --force --recursive configure config.log config.status \
                                 autom4te.cache \
                                 autom4te-${AC_VERSION}.cache; \
          ${ECHO} " done."; \
        fi
	${ECHO} -n "Deleting emacs backups${if ${LOC}, in ${LOC}}..."
	${RM} --force *~ .*~ \#*\# .\#*	
	${ECHO} " done."
	${ECHO} -n "Deleting ${call loc_of,Makefile}..."
	${RM} --force Makefile
	${ECHO} " done."
	${ECHO} "Run \`autoconf' and \`./configure' again${if ${LOC}, in ${LOC}}."
endif

# ========================================================================
# Debugging section
#
# It is important to use square brackets around the variables. Braces
# do not have the expected semantics (try echo V={a,b,c}).
#
.PHONY: env
env::
	@${ECHO} Directories
	@${ECHO} LOC=[${LOC}]
	@echo
	@${ECHO} Files
	@${ECHO} PRESENT_TEX=[${PRESENT_TEX}]
	@${ECHO} PRESENT_DOC_TEX=[${PRESENT_DOC_TEX}]
	@${ECHO} SLAVE_TEX=[${SLAVE_TEX}]
	@${ECHO} DOC_AND_SLAVE_TEX=[${DOC_AND_SLAVE_TEX}]
	@${ECHO} PRESENT_DOC=[${PRESENT_DOC}]
	@${ECHO} DOC=[${DOC}]
	@${ECHO} DOC_CLASS=[${DOC_CLASS}]
	@${ECHO} DEP=[${DEP}]
	@${ECHO} BIBLIO=[${BIBLIO}]
	@${ECHO} TEX=[${TEX}]
	@${ECHO} AUX=[${AUX}]
	@${ECHO} ALL_IST=[${ALL_IST}]
	@${ECHO} IST=[${IST}]
	@${ECHO} MAKEIDX=[${MAKEIDX}]
	@${ECHO} BST_BASENAME=[${BST_BASENAME}]
	@${ECHO} BIB_BASENAMES=[${BIB_BASENAMES}]
	@${ECHO} ALL_BIB=[${ALL_BIB}]
	@${ECHO} ALL_BST=[${ALL_BST}]
	@${ECHO} PRESENT_BIB=[${PRESENT_BIB}]
	@${ECHO} MISSING_BIB=[${MISSING_BIB}]
	@${ECHO} BIB=[${BIB}]
	@${ECHO} BBL=[${BBL}]
	@${ECHO} BST=[${BST}]
	@${ECHO} PRESENT_BST=[${PRESENT_BST}]
	@${ECHO} BLG=[${BLG}]
	@${ECHO} TOC=[${TOC}]
	@${ECHO} TOCBIBIND=[${TOCBIBIND}]
	@${ECHO} TOC_WARNING=[${TOC_WARNING}]
	@${ECHO} LOF=[${LOF}]
	@${ECHO} DVI=[${DVI}]
	@${ECHO} PS=[${PS}]
	@${ECHO} PS_FROM_TEX=[${PS_FROM_TEX}]
	@${ECHO} PDF=[${PDF}]
	@${ECHO} 4UPPS=[${4UPPS}]
#	@${ECHO} EPS=[${EPS}]
#	@${ECHO} EPS_BASE=[${EPS_BASE}]
	@${ECHO} EPS_FROM_FIG=[${EPS_FROM_FIG}]
	@${ECHO} EPS_FROM_GIF=[${EPS_FROM_GIF}]
	@${ECHO} EPS_FROM_TEX=[${EPS_FROM_TEX}]
	@${ECHO} FIG=[${FIG}]
	@${ECHO} FIG_BASE=[${FIG_BASE}]
	@${ECHO} GIF=[${GIF}]
	@${ECHO} GIF_BASE=[${GIF_BASE}]
	@${ECHO} TEX_BASE=[${TEX_BASE}]
	@${ECHO} PS_FROM_TEX=[${PS_FROM_TEX}]
	@${ECHO} BBX=[${BBX}]
	@${ECHO} MLL=[${MLL}]
	@${ECHO} MLY=[${MLY}]
	@${ECHO} MLI=[${MLI}]
	@${ECHO} ML=[${ML}]
	@${ECHO} OCAML_SRC=[${OCAML_SRC}]
	@echo
	@${ECHO} Packages
	@${ECHO} PACKAGES=[${PACKAGES}]
#	@${ECHO} OCW=[${OCW}]
	@${ECHO} TIMES=[${TIMES}]
	@${ECHO} FONTENC=[${FONTENC}]
	@${ECHO} AMSSYMB=[${AMSSYMB}]
	@${ECHO} AMSMATH=[${AMSMATH}]
	@${ECHO} AMSFONTS=[${AMSFONTS}]
	@${ECHO} PSTRICKS=[${PSTRICKS}]
	@${ECHO} AE=[${AE}]
	@${ECHO} GRAPHICS=[${GRAPHICS}]
	@${ECHO} GRAPHICX=[${GRAPHICX}]
	@${ECHO} HYPERREF=[${HYPERREF}]
	@echo
	@${ECHO} Tools
	@${ECHO} LATEX=[${LATEX}]
	@${ECHO} BIBTEX=[${BIBTEX}]
	@${ECHO} DVIPS=[${DVIPS}]
	@${ECHO} PSNUP=[${PSNUP}]
	@${ECHO} DVIPDFM=[${DVIPDFM}]
	@${ECHO} DVIPDF=[${DVIPDF}]
	@${ECHO} PS2PDF=[${PS2PDF}]
	@${ECHO} PDFTEX=[${PDFTEX}]
	@${ECHO} HEVEA=[${HEVEA}]
	@${ECHO} OCAMLWEB=[${OCAMLWEB}]
	@echo
	@${ECHO} Options
	@${ECHO} PP=[${PP}]
	@${ECHO} PAGES=[${PAGES}]
	@${ECHO} DVIPS_PP=[${DVIPS_PP}]
	@${ECHO} DVIPS_OPT=[${DVIPS_OPT}]
	@${ECHO} DVIPS_FIG_OPT=[${DVIPS_FIG_OPT}]
	@${ECHO} DVIPDFM_OPT=[${DVIPDFM_OPT}]
	@${ECHO} PS2PDF_OPT=[${PS2PDF_OPT}]
	@${ECHO} PRINTER=[${PRINTER}]
	@echo
	@${ECHO} SUFFIXES=[${SUFFIXES}]
	@echo
	@${ECHO} TABLE_OF_CONTENTS=[${TABLE_OF_CONTENTS}]
	@echo
	@${ECHO} PHONY_TARGETS=[${PHONY_TARGETS}]
	@${ECHO} VERB=[${VERB}]

%: ;
